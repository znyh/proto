// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

// package 命名使用 {appid}.{version} 的方式, version 形如 v1, v2 ..

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// zset
type ZSetLoadRangeReq struct {
	From                 int32    `protobuf:"varint,1,opt,name=From,proto3" json:"From,omitempty"`
	To                   int32    `protobuf:"varint,2,opt,name=To,proto3" json:"To,omitempty"`
	SetName              string   `protobuf:"bytes,3,opt,name=SetName,proto3" json:"SetName,omitempty"`
	GameId               int32    `protobuf:"varint,4,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZSetLoadRangeReq) Reset()         { *m = ZSetLoadRangeReq{} }
func (m *ZSetLoadRangeReq) String() string { return proto.CompactTextString(m) }
func (*ZSetLoadRangeReq) ProtoMessage()    {}
func (*ZSetLoadRangeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *ZSetLoadRangeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetLoadRangeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetLoadRangeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetLoadRangeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetLoadRangeReq.Merge(m, src)
}
func (m *ZSetLoadRangeReq) XXX_Size() int {
	return m.Size()
}
func (m *ZSetLoadRangeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetLoadRangeReq.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetLoadRangeReq proto.InternalMessageInfo

type ZSetRangeData struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Score                int64    `protobuf:"varint,2,opt,name=Score,proto3" json:"Score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZSetRangeData) Reset()         { *m = ZSetRangeData{} }
func (m *ZSetRangeData) String() string { return proto.CompactTextString(m) }
func (*ZSetRangeData) ProtoMessage()    {}
func (*ZSetRangeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *ZSetRangeData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetRangeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetRangeData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetRangeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetRangeData.Merge(m, src)
}
func (m *ZSetRangeData) XXX_Size() int {
	return m.Size()
}
func (m *ZSetRangeData) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetRangeData.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetRangeData proto.InternalMessageInfo

type ZSetLoadRangeResp struct {
	Rank                 []*ZSetRangeData `protobuf:"bytes,1,rep,name=Rank,proto3" json:"Rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ZSetLoadRangeResp) Reset()         { *m = ZSetLoadRangeResp{} }
func (m *ZSetLoadRangeResp) String() string { return proto.CompactTextString(m) }
func (*ZSetLoadRangeResp) ProtoMessage()    {}
func (*ZSetLoadRangeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *ZSetLoadRangeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetLoadRangeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetLoadRangeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetLoadRangeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetLoadRangeResp.Merge(m, src)
}
func (m *ZSetLoadRangeResp) XXX_Size() int {
	return m.Size()
}
func (m *ZSetLoadRangeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetLoadRangeResp.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetLoadRangeResp proto.InternalMessageInfo

type ZSetReq struct {
	SetName              string   `protobuf:"bytes,1,opt,name=SetName,proto3" json:"SetName,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZSetReq) Reset()         { *m = ZSetReq{} }
func (m *ZSetReq) String() string { return proto.CompactTextString(m) }
func (*ZSetReq) ProtoMessage()    {}
func (*ZSetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *ZSetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetReq.Merge(m, src)
}
func (m *ZSetReq) XXX_Size() int {
	return m.Size()
}
func (m *ZSetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetReq.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetReq proto.InternalMessageInfo

type ZSetGetScoreResp struct {
	Score                int64    `protobuf:"varint,1,opt,name=Score,proto3" json:"Score,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZSetGetScoreResp) Reset()         { *m = ZSetGetScoreResp{} }
func (m *ZSetGetScoreResp) String() string { return proto.CompactTextString(m) }
func (*ZSetGetScoreResp) ProtoMessage()    {}
func (*ZSetGetScoreResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *ZSetGetScoreResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetGetScoreResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetGetScoreResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetGetScoreResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetGetScoreResp.Merge(m, src)
}
func (m *ZSetGetScoreResp) XXX_Size() int {
	return m.Size()
}
func (m *ZSetGetScoreResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetGetScoreResp.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetGetScoreResp proto.InternalMessageInfo

type ZSetUpdateScoreReq struct {
	Score                int64    `protobuf:"varint,1,opt,name=Score,proto3" json:"Score,omitempty"`
	SetName              string   `protobuf:"bytes,2,opt,name=SetName,proto3" json:"SetName,omitempty"`
	Key                  string   `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	GameId               int32    `protobuf:"varint,4,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZSetUpdateScoreReq) Reset()         { *m = ZSetUpdateScoreReq{} }
func (m *ZSetUpdateScoreReq) String() string { return proto.CompactTextString(m) }
func (*ZSetUpdateScoreReq) ProtoMessage()    {}
func (*ZSetUpdateScoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *ZSetUpdateScoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetUpdateScoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetUpdateScoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetUpdateScoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetUpdateScoreReq.Merge(m, src)
}
func (m *ZSetUpdateScoreReq) XXX_Size() int {
	return m.Size()
}
func (m *ZSetUpdateScoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetUpdateScoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetUpdateScoreReq proto.InternalMessageInfo

type ZSetGetRankResp struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Score                int64    `protobuf:"varint,2,opt,name=Score,proto3" json:"Score,omitempty"`
	Rank                 int64    `protobuf:"varint,3,opt,name=Rank,proto3" json:"Rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZSetGetRankResp) Reset()         { *m = ZSetGetRankResp{} }
func (m *ZSetGetRankResp) String() string { return proto.CompactTextString(m) }
func (*ZSetGetRankResp) ProtoMessage()    {}
func (*ZSetGetRankResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *ZSetGetRankResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetGetRankResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetGetRankResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetGetRankResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetGetRankResp.Merge(m, src)
}
func (m *ZSetGetRankResp) XXX_Size() int {
	return m.Size()
}
func (m *ZSetGetRankResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetGetRankResp.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetGetRankResp proto.InternalMessageInfo

type ZSetRefreshRankReq struct {
	Delta                int64    `protobuf:"varint,1,opt,name=Delta,proto3" json:"Delta,omitempty"`
	SetName              string   `protobuf:"bytes,2,opt,name=SetName,proto3" json:"SetName,omitempty"`
	Key                  string   `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	GameId               int32    `protobuf:"varint,4,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZSetRefreshRankReq) Reset()         { *m = ZSetRefreshRankReq{} }
func (m *ZSetRefreshRankReq) String() string { return proto.CompactTextString(m) }
func (*ZSetRefreshRankReq) ProtoMessage()    {}
func (*ZSetRefreshRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *ZSetRefreshRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZSetRefreshRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZSetRefreshRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZSetRefreshRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZSetRefreshRankReq.Merge(m, src)
}
func (m *ZSetRefreshRankReq) XXX_Size() int {
	return m.Size()
}
func (m *ZSetRefreshRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ZSetRefreshRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_ZSetRefreshRankReq proto.InternalMessageInfo

// list
type HListReq struct {
	Item                 string   `protobuf:"bytes,1,opt,name=Item,proto3" json:"Item,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	ListName             string   `protobuf:"bytes,3,opt,name=ListName,proto3" json:"ListName,omitempty"`
	GameId               int32    `protobuf:"varint,4,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HListReq) Reset()         { *m = HListReq{} }
func (m *HListReq) String() string { return proto.CompactTextString(m) }
func (*HListReq) ProtoMessage()    {}
func (*HListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *HListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HListReq.Merge(m, src)
}
func (m *HListReq) XXX_Size() int {
	return m.Size()
}
func (m *HListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HListReq.DiscardUnknown(m)
}

var xxx_messageInfo_HListReq proto.InternalMessageInfo

type HListLoadResp struct {
	Items                []string `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HListLoadResp) Reset()         { *m = HListLoadResp{} }
func (m *HListLoadResp) String() string { return proto.CompactTextString(m) }
func (*HListLoadResp) ProtoMessage()    {}
func (*HListLoadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *HListLoadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HListLoadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HListLoadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HListLoadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HListLoadResp.Merge(m, src)
}
func (m *HListLoadResp) XXX_Size() int {
	return m.Size()
}
func (m *HListLoadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_HListLoadResp.DiscardUnknown(m)
}

var xxx_messageInfo_HListLoadResp proto.InternalMessageInfo

type HListLoadRangeReq struct {
	From                 int32    `protobuf:"varint,1,opt,name=From,proto3" json:"From,omitempty"`
	To                   int32    `protobuf:"varint,2,opt,name=To,proto3" json:"To,omitempty"`
	Key                  string   `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	ListName             string   `protobuf:"bytes,4,opt,name=ListName,proto3" json:"ListName,omitempty"`
	GameId               int32    `protobuf:"varint,5,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HListLoadRangeReq) Reset()         { *m = HListLoadRangeReq{} }
func (m *HListLoadRangeReq) String() string { return proto.CompactTextString(m) }
func (*HListLoadRangeReq) ProtoMessage()    {}
func (*HListLoadRangeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *HListLoadRangeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HListLoadRangeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HListLoadRangeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HListLoadRangeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HListLoadRangeReq.Merge(m, src)
}
func (m *HListLoadRangeReq) XXX_Size() int {
	return m.Size()
}
func (m *HListLoadRangeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HListLoadRangeReq.DiscardUnknown(m)
}

var xxx_messageInfo_HListLoadRangeReq proto.InternalMessageInfo

type HListPopResp struct {
	Value                string   `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HListPopResp) Reset()         { *m = HListPopResp{} }
func (m *HListPopResp) String() string { return proto.CompactTextString(m) }
func (*HListPopResp) ProtoMessage()    {}
func (*HListPopResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *HListPopResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HListPopResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HListPopResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HListPopResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HListPopResp.Merge(m, src)
}
func (m *HListPopResp) XXX_Size() int {
	return m.Size()
}
func (m *HListPopResp) XXX_DiscardUnknown() {
	xxx_messageInfo_HListPopResp.DiscardUnknown(m)
}

var xxx_messageInfo_HListPopResp proto.InternalMessageInfo

///////////////////////////////////////////
type CommonResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonResp) Reset()         { *m = CommonResp{} }
func (m *CommonResp) String() string { return proto.CompactTextString(m) }
func (*CommonResp) ProtoMessage()    {}
func (*CommonResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *CommonResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonResp.Merge(m, src)
}
func (m *CommonResp) XXX_Size() int {
	return m.Size()
}
func (m *CommonResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonResp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonResp proto.InternalMessageInfo

type KeyValue struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty" form:"Key" validate:"required"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" form:"value" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

type UpdateKeyValuesReq struct {
	GameID               int32       `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID,omitempty"`
	Items                []*KeyValue `protobuf:"bytes,2,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UpdateKeyValuesReq) Reset()         { *m = UpdateKeyValuesReq{} }
func (m *UpdateKeyValuesReq) String() string { return proto.CompactTextString(m) }
func (*UpdateKeyValuesReq) ProtoMessage()    {}
func (*UpdateKeyValuesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *UpdateKeyValuesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateKeyValuesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateKeyValuesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateKeyValuesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateKeyValuesReq.Merge(m, src)
}
func (m *UpdateKeyValuesReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateKeyValuesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateKeyValuesReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateKeyValuesReq proto.InternalMessageInfo

type LoadValuesReq struct {
	GameID               int32    `protobuf:"varint,1,opt,name=GameID,proto3" json:"GameID,omitempty"`
	Keys                 []string `protobuf:"bytes,2,rep,name=Keys,proto3" json:"Keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadValuesReq) Reset()         { *m = LoadValuesReq{} }
func (m *LoadValuesReq) String() string { return proto.CompactTextString(m) }
func (*LoadValuesReq) ProtoMessage()    {}
func (*LoadValuesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *LoadValuesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadValuesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadValuesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadValuesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadValuesReq.Merge(m, src)
}
func (m *LoadValuesReq) XXX_Size() int {
	return m.Size()
}
func (m *LoadValuesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadValuesReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoadValuesReq proto.InternalMessageInfo

type LoadValuesResp struct {
	Items                []*KeyValue `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LoadValuesResp) Reset()         { *m = LoadValuesResp{} }
func (m *LoadValuesResp) String() string { return proto.CompactTextString(m) }
func (*LoadValuesResp) ProtoMessage()    {}
func (*LoadValuesResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *LoadValuesResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadValuesResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadValuesResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadValuesResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadValuesResp.Merge(m, src)
}
func (m *LoadValuesResp) XXX_Size() int {
	return m.Size()
}
func (m *LoadValuesResp) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadValuesResp.DiscardUnknown(m)
}

var xxx_messageInfo_LoadValuesResp proto.InternalMessageInfo

type SetExpireReq struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=Time,proto3" json:"Time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetExpireReq) Reset()         { *m = SetExpireReq{} }
func (m *SetExpireReq) String() string { return proto.CompactTextString(m) }
func (*SetExpireReq) ProtoMessage()    {}
func (*SetExpireReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *SetExpireReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetExpireReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetExpireReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetExpireReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetExpireReq.Merge(m, src)
}
func (m *SetExpireReq) XXX_Size() int {
	return m.Size()
}
func (m *SetExpireReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetExpireReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetExpireReq proto.InternalMessageInfo

type LoadExpireReq struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadExpireReq) Reset()         { *m = LoadExpireReq{} }
func (m *LoadExpireReq) String() string { return proto.CompactTextString(m) }
func (*LoadExpireReq) ProtoMessage()    {}
func (*LoadExpireReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *LoadExpireReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadExpireReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadExpireReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadExpireReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadExpireReq.Merge(m, src)
}
func (m *LoadExpireReq) XXX_Size() int {
	return m.Size()
}
func (m *LoadExpireReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadExpireReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoadExpireReq proto.InternalMessageInfo

type LoadExpireResp struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=Time,proto3" json:"Time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadExpireResp) Reset()         { *m = LoadExpireResp{} }
func (m *LoadExpireResp) String() string { return proto.CompactTextString(m) }
func (*LoadExpireResp) ProtoMessage()    {}
func (*LoadExpireResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *LoadExpireResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadExpireResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadExpireResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadExpireResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadExpireResp.Merge(m, src)
}
func (m *LoadExpireResp) XXX_Size() int {
	return m.Size()
}
func (m *LoadExpireResp) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadExpireResp.DiscardUnknown(m)
}

var xxx_messageInfo_LoadExpireResp proto.InternalMessageInfo

type IncrGameDataReq struct {
	GameId               int32    `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	GroupId              int32    `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	Key                  string   `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                int64    `protobuf:"varint,4,opt,name=Value,proto3" json:"Value,omitempty"`
	HashName             string   `protobuf:"bytes,5,opt,name=HashName,proto3" json:"HashName,omitempty"`
	ServerId             string   `protobuf:"bytes,6,opt,name=ServerId,proto3" json:"ServerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IncrGameDataReq) Reset()         { *m = IncrGameDataReq{} }
func (m *IncrGameDataReq) String() string { return proto.CompactTextString(m) }
func (*IncrGameDataReq) ProtoMessage()    {}
func (*IncrGameDataReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *IncrGameDataReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrGameDataReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrGameDataReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrGameDataReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrGameDataReq.Merge(m, src)
}
func (m *IncrGameDataReq) XXX_Size() int {
	return m.Size()
}
func (m *IncrGameDataReq) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrGameDataReq.DiscardUnknown(m)
}

var xxx_messageInfo_IncrGameDataReq proto.InternalMessageInfo

type LoadGameDataReq struct {
	GameId               int32    `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	GroupId              int32    `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	Key                  string   `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	HashName             string   `protobuf:"bytes,4,opt,name=HashName,proto3" json:"HashName,omitempty"`
	ServerId             string   `protobuf:"bytes,5,opt,name=ServerId,proto3" json:"ServerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadGameDataReq) Reset()         { *m = LoadGameDataReq{} }
func (m *LoadGameDataReq) String() string { return proto.CompactTextString(m) }
func (*LoadGameDataReq) ProtoMessage()    {}
func (*LoadGameDataReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *LoadGameDataReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadGameDataReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadGameDataReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadGameDataReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadGameDataReq.Merge(m, src)
}
func (m *LoadGameDataReq) XXX_Size() int {
	return m.Size()
}
func (m *LoadGameDataReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadGameDataReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoadGameDataReq proto.InternalMessageInfo

type LoadGameDataResp struct {
	GameId               int32    `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	GroupId              int32    `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	Key                  string   `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                int64    `protobuf:"varint,4,opt,name=Value,proto3" json:"Value,omitempty"`
	HashName             string   `protobuf:"bytes,5,opt,name=HashName,proto3" json:"HashName,omitempty"`
	ServerId             string   `protobuf:"bytes,6,opt,name=ServerId,proto3" json:"ServerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadGameDataResp) Reset()         { *m = LoadGameDataResp{} }
func (m *LoadGameDataResp) String() string { return proto.CompactTextString(m) }
func (*LoadGameDataResp) ProtoMessage()    {}
func (*LoadGameDataResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *LoadGameDataResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadGameDataResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadGameDataResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadGameDataResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadGameDataResp.Merge(m, src)
}
func (m *LoadGameDataResp) XXX_Size() int {
	return m.Size()
}
func (m *LoadGameDataResp) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadGameDataResp.DiscardUnknown(m)
}

var xxx_messageInfo_LoadGameDataResp proto.InternalMessageInfo

// set
type SetReq struct {
	GameId               int32    `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	SetName              string   `protobuf:"bytes,2,opt,name=SetName,proto3" json:"SetName,omitempty"`
	Item                 string   `protobuf:"bytes,3,opt,name=Item,proto3" json:"Item,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetReq) Reset()         { *m = SetReq{} }
func (m *SetReq) String() string { return proto.CompactTextString(m) }
func (*SetReq) ProtoMessage()    {}
func (*SetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *SetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetReq.Merge(m, src)
}
func (m *SetReq) XXX_Size() int {
	return m.Size()
}
func (m *SetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetReq proto.InternalMessageInfo

type SetMembersResp struct {
	Members              []string `protobuf:"bytes,1,rep,name=Members,proto3" json:"Members,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetMembersResp) Reset()         { *m = SetMembersResp{} }
func (m *SetMembersResp) String() string { return proto.CompactTextString(m) }
func (*SetMembersResp) ProtoMessage()    {}
func (*SetMembersResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *SetMembersResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetMembersResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetMembersResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetMembersResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMembersResp.Merge(m, src)
}
func (m *SetMembersResp) XXX_Size() int {
	return m.Size()
}
func (m *SetMembersResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMembersResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetMembersResp proto.InternalMessageInfo

type SetRandomReq struct {
	GameId               int32    `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	SetName              string   `protobuf:"bytes,2,opt,name=SetName,proto3" json:"SetName,omitempty"`
	Count                int64    `protobuf:"varint,3,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetRandomReq) Reset()         { *m = SetRandomReq{} }
func (m *SetRandomReq) String() string { return proto.CompactTextString(m) }
func (*SetRandomReq) ProtoMessage()    {}
func (*SetRandomReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *SetRandomReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRandomReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRandomReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRandomReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRandomReq.Merge(m, src)
}
func (m *SetRandomReq) XXX_Size() int {
	return m.Size()
}
func (m *SetRandomReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRandomReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetRandomReq proto.InternalMessageInfo

type SetRandomResp struct {
	Members              []string `protobuf:"bytes,1,rep,name=Members,proto3" json:"Members,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetRandomResp) Reset()         { *m = SetRandomResp{} }
func (m *SetRandomResp) String() string { return proto.CompactTextString(m) }
func (*SetRandomResp) ProtoMessage()    {}
func (*SetRandomResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *SetRandomResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRandomResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRandomResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRandomResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRandomResp.Merge(m, src)
}
func (m *SetRandomResp) XXX_Size() int {
	return m.Size()
}
func (m *SetRandomResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRandomResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetRandomResp proto.InternalMessageInfo

type SetIsMemberResp struct {
	IsMember             bool     `protobuf:"varint,1,opt,name=IsMember,proto3" json:"IsMember,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetIsMemberResp) Reset()         { *m = SetIsMemberResp{} }
func (m *SetIsMemberResp) String() string { return proto.CompactTextString(m) }
func (*SetIsMemberResp) ProtoMessage()    {}
func (*SetIsMemberResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *SetIsMemberResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetIsMemberResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetIsMemberResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetIsMemberResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetIsMemberResp.Merge(m, src)
}
func (m *SetIsMemberResp) XXX_Size() int {
	return m.Size()
}
func (m *SetIsMemberResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetIsMemberResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetIsMemberResp proto.InternalMessageInfo

type HSetUpdateReq struct {
	Item                 *KeyValue `protobuf:"bytes,1,opt,name=Item,proto3" json:"Item,omitempty"`
	HashName             string    `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32     `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *HSetUpdateReq) Reset()         { *m = HSetUpdateReq{} }
func (m *HSetUpdateReq) String() string { return proto.CompactTextString(m) }
func (*HSetUpdateReq) ProtoMessage()    {}
func (*HSetUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *HSetUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetUpdateReq.Merge(m, src)
}
func (m *HSetUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetUpdateReq proto.InternalMessageInfo

type HSetLoadReq struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	HashName             string   `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HSetLoadReq) Reset()         { *m = HSetLoadReq{} }
func (m *HSetLoadReq) String() string { return proto.CompactTextString(m) }
func (*HSetLoadReq) ProtoMessage()    {}
func (*HSetLoadReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *HSetLoadReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetLoadReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetLoadReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetLoadReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetLoadReq.Merge(m, src)
}
func (m *HSetLoadReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetLoadReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetLoadReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetLoadReq proto.InternalMessageInfo

type HSetLoadResp struct {
	Item                 *KeyValue `protobuf:"bytes,1,opt,name=Item,proto3" json:"Item,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *HSetLoadResp) Reset()         { *m = HSetLoadResp{} }
func (m *HSetLoadResp) String() string { return proto.CompactTextString(m) }
func (*HSetLoadResp) ProtoMessage()    {}
func (*HSetLoadResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *HSetLoadResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetLoadResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetLoadResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetLoadResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetLoadResp.Merge(m, src)
}
func (m *HSetLoadResp) XXX_Size() int {
	return m.Size()
}
func (m *HSetLoadResp) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetLoadResp.DiscardUnknown(m)
}

var xxx_messageInfo_HSetLoadResp proto.InternalMessageInfo

type HSetDelReq struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	HashName             string   `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HSetDelReq) Reset()         { *m = HSetDelReq{} }
func (m *HSetDelReq) String() string { return proto.CompactTextString(m) }
func (*HSetDelReq) ProtoMessage()    {}
func (*HSetDelReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *HSetDelReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetDelReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetDelReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetDelReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetDelReq.Merge(m, src)
}
func (m *HSetDelReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetDelReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetDelReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetDelReq proto.InternalMessageInfo

type HSetUpdateValuesReq struct {
	Items                []*KeyValue `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	HashName             string      `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32       `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *HSetUpdateValuesReq) Reset()         { *m = HSetUpdateValuesReq{} }
func (m *HSetUpdateValuesReq) String() string { return proto.CompactTextString(m) }
func (*HSetUpdateValuesReq) ProtoMessage()    {}
func (*HSetUpdateValuesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *HSetUpdateValuesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetUpdateValuesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetUpdateValuesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetUpdateValuesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetUpdateValuesReq.Merge(m, src)
}
func (m *HSetUpdateValuesReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetUpdateValuesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetUpdateValuesReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetUpdateValuesReq proto.InternalMessageInfo

type HSetLoadValuesReq struct {
	Keys                 []string `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	HashName             string   `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HSetLoadValuesReq) Reset()         { *m = HSetLoadValuesReq{} }
func (m *HSetLoadValuesReq) String() string { return proto.CompactTextString(m) }
func (*HSetLoadValuesReq) ProtoMessage()    {}
func (*HSetLoadValuesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *HSetLoadValuesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetLoadValuesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetLoadValuesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetLoadValuesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetLoadValuesReq.Merge(m, src)
}
func (m *HSetLoadValuesReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetLoadValuesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetLoadValuesReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetLoadValuesReq proto.InternalMessageInfo

type HSetLoadValuesResp struct {
	Items                []*KeyValue `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *HSetLoadValuesResp) Reset()         { *m = HSetLoadValuesResp{} }
func (m *HSetLoadValuesResp) String() string { return proto.CompactTextString(m) }
func (*HSetLoadValuesResp) ProtoMessage()    {}
func (*HSetLoadValuesResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *HSetLoadValuesResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetLoadValuesResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetLoadValuesResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetLoadValuesResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetLoadValuesResp.Merge(m, src)
}
func (m *HSetLoadValuesResp) XXX_Size() int {
	return m.Size()
}
func (m *HSetLoadValuesResp) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetLoadValuesResp.DiscardUnknown(m)
}

var xxx_messageInfo_HSetLoadValuesResp proto.InternalMessageInfo

type HSetDelValuesReq struct {
	Keys                 []string `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	HashName             string   `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32    `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HSetDelValuesReq) Reset()         { *m = HSetDelValuesReq{} }
func (m *HSetDelValuesReq) String() string { return proto.CompactTextString(m) }
func (*HSetDelValuesReq) ProtoMessage()    {}
func (*HSetDelValuesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *HSetDelValuesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetDelValuesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetDelValuesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetDelValuesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetDelValuesReq.Merge(m, src)
}
func (m *HSetDelValuesReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetDelValuesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetDelValuesReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetDelValuesReq proto.InternalMessageInfo

type HSetDelHashReq struct {
	HashName             string   `protobuf:"bytes,1,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32    `protobuf:"varint,2,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HSetDelHashReq) Reset()         { *m = HSetDelHashReq{} }
func (m *HSetDelHashReq) String() string { return proto.CompactTextString(m) }
func (*HSetDelHashReq) ProtoMessage()    {}
func (*HSetDelHashReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *HSetDelHashReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetDelHashReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetDelHashReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetDelHashReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetDelHashReq.Merge(m, src)
}
func (m *HSetDelHashReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetDelHashReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetDelHashReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetDelHashReq proto.InternalMessageInfo

type HSetAddReq struct {
	Item                 *KeyValue `protobuf:"bytes,1,opt,name=Item,proto3" json:"Item,omitempty"`
	HashName             string    `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32     `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *HSetAddReq) Reset()         { *m = HSetAddReq{} }
func (m *HSetAddReq) String() string { return proto.CompactTextString(m) }
func (*HSetAddReq) ProtoMessage()    {}
func (*HSetAddReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *HSetAddReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetAddReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetAddReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetAddReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetAddReq.Merge(m, src)
}
func (m *HSetAddReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetAddReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetAddReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetAddReq proto.InternalMessageInfo

type HSetIncrReq struct {
	Item                 *KeyValue `protobuf:"bytes,1,opt,name=Item,proto3" json:"Item,omitempty"`
	HashName             string    `protobuf:"bytes,2,opt,name=HashName,proto3" json:"HashName,omitempty"`
	GameId               int32     `protobuf:"varint,3,opt,name=GameId,proto3" json:"GameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *HSetIncrReq) Reset()         { *m = HSetIncrReq{} }
func (m *HSetIncrReq) String() string { return proto.CompactTextString(m) }
func (*HSetIncrReq) ProtoMessage()    {}
func (*HSetIncrReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *HSetIncrReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HSetIncrReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HSetIncrReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HSetIncrReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HSetIncrReq.Merge(m, src)
}
func (m *HSetIncrReq) XXX_Size() int {
	return m.Size()
}
func (m *HSetIncrReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HSetIncrReq.DiscardUnknown(m)
}

var xxx_messageInfo_HSetIncrReq proto.InternalMessageInfo

type UpdateGameArenaReq struct {
	GameArena            *GameArena `protobuf:"bytes,1,opt,name=GameArena,proto3" json:"GameArena,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *UpdateGameArenaReq) Reset()         { *m = UpdateGameArenaReq{} }
func (m *UpdateGameArenaReq) String() string { return proto.CompactTextString(m) }
func (*UpdateGameArenaReq) ProtoMessage()    {}
func (*UpdateGameArenaReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *UpdateGameArenaReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGameArenaReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGameArenaReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGameArenaReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGameArenaReq.Merge(m, src)
}
func (m *UpdateGameArenaReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGameArenaReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGameArenaReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGameArenaReq proto.InternalMessageInfo

type UpdateGameArenaResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateGameArenaResp) Reset()         { *m = UpdateGameArenaResp{} }
func (m *UpdateGameArenaResp) String() string { return proto.CompactTextString(m) }
func (*UpdateGameArenaResp) ProtoMessage()    {}
func (*UpdateGameArenaResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *UpdateGameArenaResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGameArenaResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGameArenaResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGameArenaResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGameArenaResp.Merge(m, src)
}
func (m *UpdateGameArenaResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGameArenaResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGameArenaResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGameArenaResp proto.InternalMessageInfo

type GetGameArenaReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGameArenaReq) Reset()         { *m = GetGameArenaReq{} }
func (m *GetGameArenaReq) String() string { return proto.CompactTextString(m) }
func (*GetGameArenaReq) ProtoMessage()    {}
func (*GetGameArenaReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *GetGameArenaReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGameArenaReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGameArenaReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGameArenaReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGameArenaReq.Merge(m, src)
}
func (m *GetGameArenaReq) XXX_Size() int {
	return m.Size()
}
func (m *GetGameArenaReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGameArenaReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetGameArenaReq proto.InternalMessageInfo

type GetGameArenaResp struct {
	GameArenas           []*GameArena `protobuf:"bytes,1,rep,name=GameArenas,proto3" json:"GameArenas,omitempty"`
	TimeStamp            int64        `protobuf:"varint,2,opt,name=TimeStamp,proto3" json:"TimeStamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetGameArenaResp) Reset()         { *m = GetGameArenaResp{} }
func (m *GetGameArenaResp) String() string { return proto.CompactTextString(m) }
func (*GetGameArenaResp) ProtoMessage()    {}
func (*GetGameArenaResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *GetGameArenaResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGameArenaResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGameArenaResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGameArenaResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGameArenaResp.Merge(m, src)
}
func (m *GetGameArenaResp) XXX_Size() int {
	return m.Size()
}
func (m *GetGameArenaResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGameArenaResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetGameArenaResp proto.InternalMessageInfo

type DeleteGameArenaReq struct {
	GameArena            *GameArena `protobuf:"bytes,1,opt,name=GameArena,proto3" json:"GameArena,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeleteGameArenaReq) Reset()         { *m = DeleteGameArenaReq{} }
func (m *DeleteGameArenaReq) String() string { return proto.CompactTextString(m) }
func (*DeleteGameArenaReq) ProtoMessage()    {}
func (*DeleteGameArenaReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{43}
}
func (m *DeleteGameArenaReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteGameArenaReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteGameArenaReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteGameArenaReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteGameArenaReq.Merge(m, src)
}
func (m *DeleteGameArenaReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteGameArenaReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteGameArenaReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteGameArenaReq proto.InternalMessageInfo

type DeleteGameArenaResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteGameArenaResp) Reset()         { *m = DeleteGameArenaResp{} }
func (m *DeleteGameArenaResp) String() string { return proto.CompactTextString(m) }
func (*DeleteGameArenaResp) ProtoMessage()    {}
func (*DeleteGameArenaResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{44}
}
func (m *DeleteGameArenaResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteGameArenaResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteGameArenaResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteGameArenaResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteGameArenaResp.Merge(m, src)
}
func (m *DeleteGameArenaResp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteGameArenaResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteGameArenaResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteGameArenaResp proto.InternalMessageInfo

type GameArena struct {
	GameId               int32    `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	GroupId              int32    `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	ArenaInfo            string   `protobuf:"bytes,3,opt,name=ArenaInfo,proto3" json:"ArenaInfo,omitempty"`
	ExtraData            string   `protobuf:"bytes,4,opt,name=ExtraData,proto3" json:"ExtraData,omitempty"`
	MatchId              int32    `protobuf:"varint,5,opt,name=MatchId,proto3" json:"MatchId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameArena) Reset()         { *m = GameArena{} }
func (m *GameArena) String() string { return proto.CompactTextString(m) }
func (*GameArena) ProtoMessage()    {}
func (*GameArena) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45}
}
func (m *GameArena) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameArena) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameArena.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameArena) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameArena.Merge(m, src)
}
func (m *GameArena) XXX_Size() int {
	return m.Size()
}
func (m *GameArena) XXX_DiscardUnknown() {
	xxx_messageInfo_GameArena.DiscardUnknown(m)
}

var xxx_messageInfo_GameArena proto.InternalMessageInfo

type LoadGameAvoidInjuryReq struct {
	GameId               int64    `protobuf:"varint,1,opt,name=gameId,proto3" json:"gameId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadGameAvoidInjuryReq) Reset()         { *m = LoadGameAvoidInjuryReq{} }
func (m *LoadGameAvoidInjuryReq) String() string { return proto.CompactTextString(m) }
func (*LoadGameAvoidInjuryReq) ProtoMessage()    {}
func (*LoadGameAvoidInjuryReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{46}
}
func (m *LoadGameAvoidInjuryReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadGameAvoidInjuryReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadGameAvoidInjuryReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadGameAvoidInjuryReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadGameAvoidInjuryReq.Merge(m, src)
}
func (m *LoadGameAvoidInjuryReq) XXX_Size() int {
	return m.Size()
}
func (m *LoadGameAvoidInjuryReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadGameAvoidInjuryReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoadGameAvoidInjuryReq proto.InternalMessageInfo

type LoadGameAvoidInjuryResp struct {
	ProxyMap             map[string]*AvoidHurtMap `protobuf:"bytes,1,rep,name=proxyMap,proto3" json:"proxyMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LoadGameAvoidInjuryResp) Reset()         { *m = LoadGameAvoidInjuryResp{} }
func (m *LoadGameAvoidInjuryResp) String() string { return proto.CompactTextString(m) }
func (*LoadGameAvoidInjuryResp) ProtoMessage()    {}
func (*LoadGameAvoidInjuryResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{47}
}
func (m *LoadGameAvoidInjuryResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadGameAvoidInjuryResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadGameAvoidInjuryResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadGameAvoidInjuryResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadGameAvoidInjuryResp.Merge(m, src)
}
func (m *LoadGameAvoidInjuryResp) XXX_Size() int {
	return m.Size()
}
func (m *LoadGameAvoidInjuryResp) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadGameAvoidInjuryResp.DiscardUnknown(m)
}

var xxx_messageInfo_LoadGameAvoidInjuryResp proto.InternalMessageInfo

type AvoidHurtMap struct {
	GameId               int64                 `protobuf:"varint,1,opt,name=gameId,proto3" json:"gameId,omitempty"`
	Name                 string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc                 string                `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	Type                 int64                 `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	AvoidHurtMap         map[string]*AvoidHurt `protobuf:"bytes,10,rep,name=avoidHurtMap,proto3" json:"avoidHurtMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *AvoidHurtMap) Reset()         { *m = AvoidHurtMap{} }
func (m *AvoidHurtMap) String() string { return proto.CompactTextString(m) }
func (*AvoidHurtMap) ProtoMessage()    {}
func (*AvoidHurtMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{48}
}
func (m *AvoidHurtMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvoidHurtMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AvoidHurtMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AvoidHurtMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvoidHurtMap.Merge(m, src)
}
func (m *AvoidHurtMap) XXX_Size() int {
	return m.Size()
}
func (m *AvoidHurtMap) XXX_DiscardUnknown() {
	xxx_messageInfo_AvoidHurtMap.DiscardUnknown(m)
}

var xxx_messageInfo_AvoidHurtMap proto.InternalMessageInfo

type AvoidHurt struct {
	Left                 int64    `protobuf:"varint,1,opt,name=left,proto3" json:"left,omitempty"`
	Right                int64    `protobuf:"varint,2,opt,name=right,proto3" json:"right,omitempty"`
	Extra                int64    `protobuf:"varint,3,opt,name=extra,proto3" json:"extra,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AvoidHurt) Reset()         { *m = AvoidHurt{} }
func (m *AvoidHurt) String() string { return proto.CompactTextString(m) }
func (*AvoidHurt) ProtoMessage()    {}
func (*AvoidHurt) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{49}
}
func (m *AvoidHurt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvoidHurt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AvoidHurt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AvoidHurt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvoidHurt.Merge(m, src)
}
func (m *AvoidHurt) XXX_Size() int {
	return m.Size()
}
func (m *AvoidHurt) XXX_DiscardUnknown() {
	xxx_messageInfo_AvoidHurt.DiscardUnknown(m)
}

var xxx_messageInfo_AvoidHurt proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ZSetLoadRangeReq)(nil), "share.service.v1.ZSetLoadRangeReq")
	proto.RegisterType((*ZSetRangeData)(nil), "share.service.v1.ZSetRangeData")
	proto.RegisterType((*ZSetLoadRangeResp)(nil), "share.service.v1.ZSetLoadRangeResp")
	proto.RegisterType((*ZSetReq)(nil), "share.service.v1.ZSetReq")
	proto.RegisterType((*ZSetGetScoreResp)(nil), "share.service.v1.ZSetGetScoreResp")
	proto.RegisterType((*ZSetUpdateScoreReq)(nil), "share.service.v1.ZSetUpdateScoreReq")
	proto.RegisterType((*ZSetGetRankResp)(nil), "share.service.v1.ZSetGetRankResp")
	proto.RegisterType((*ZSetRefreshRankReq)(nil), "share.service.v1.ZSetRefreshRankReq")
	proto.RegisterType((*HListReq)(nil), "share.service.v1.HListReq")
	proto.RegisterType((*HListLoadResp)(nil), "share.service.v1.HListLoadResp")
	proto.RegisterType((*HListLoadRangeReq)(nil), "share.service.v1.HListLoadRangeReq")
	proto.RegisterType((*HListPopResp)(nil), "share.service.v1.HListPopResp")
	proto.RegisterType((*CommonResp)(nil), "share.service.v1.CommonResp")
	proto.RegisterType((*KeyValue)(nil), "share.service.v1.KeyValue")
	proto.RegisterType((*UpdateKeyValuesReq)(nil), "share.service.v1.UpdateKeyValuesReq")
	proto.RegisterType((*LoadValuesReq)(nil), "share.service.v1.LoadValuesReq")
	proto.RegisterType((*LoadValuesResp)(nil), "share.service.v1.LoadValuesResp")
	proto.RegisterType((*SetExpireReq)(nil), "share.service.v1.SetExpireReq")
	proto.RegisterType((*LoadExpireReq)(nil), "share.service.v1.LoadExpireReq")
	proto.RegisterType((*LoadExpireResp)(nil), "share.service.v1.LoadExpireResp")
	proto.RegisterType((*IncrGameDataReq)(nil), "share.service.v1.IncrGameDataReq")
	proto.RegisterType((*LoadGameDataReq)(nil), "share.service.v1.LoadGameDataReq")
	proto.RegisterType((*LoadGameDataResp)(nil), "share.service.v1.LoadGameDataResp")
	proto.RegisterType((*SetReq)(nil), "share.service.v1.SetReq")
	proto.RegisterType((*SetMembersResp)(nil), "share.service.v1.SetMembersResp")
	proto.RegisterType((*SetRandomReq)(nil), "share.service.v1.SetRandomReq")
	proto.RegisterType((*SetRandomResp)(nil), "share.service.v1.SetRandomResp")
	proto.RegisterType((*SetIsMemberResp)(nil), "share.service.v1.SetIsMemberResp")
	proto.RegisterType((*HSetUpdateReq)(nil), "share.service.v1.HSetUpdateReq")
	proto.RegisterType((*HSetLoadReq)(nil), "share.service.v1.HSetLoadReq")
	proto.RegisterType((*HSetLoadResp)(nil), "share.service.v1.HSetLoadResp")
	proto.RegisterType((*HSetDelReq)(nil), "share.service.v1.HSetDelReq")
	proto.RegisterType((*HSetUpdateValuesReq)(nil), "share.service.v1.HSetUpdateValuesReq")
	proto.RegisterType((*HSetLoadValuesReq)(nil), "share.service.v1.HSetLoadValuesReq")
	proto.RegisterType((*HSetLoadValuesResp)(nil), "share.service.v1.HSetLoadValuesResp")
	proto.RegisterType((*HSetDelValuesReq)(nil), "share.service.v1.HSetDelValuesReq")
	proto.RegisterType((*HSetDelHashReq)(nil), "share.service.v1.HSetDelHashReq")
	proto.RegisterType((*HSetAddReq)(nil), "share.service.v1.HSetAddReq")
	proto.RegisterType((*HSetIncrReq)(nil), "share.service.v1.HSetIncrReq")
	proto.RegisterType((*UpdateGameArenaReq)(nil), "share.service.v1.UpdateGameArenaReq")
	proto.RegisterType((*UpdateGameArenaResp)(nil), "share.service.v1.UpdateGameArenaResp")
	proto.RegisterType((*GetGameArenaReq)(nil), "share.service.v1.GetGameArenaReq")
	proto.RegisterType((*GetGameArenaResp)(nil), "share.service.v1.GetGameArenaResp")
	proto.RegisterType((*DeleteGameArenaReq)(nil), "share.service.v1.DeleteGameArenaReq")
	proto.RegisterType((*DeleteGameArenaResp)(nil), "share.service.v1.DeleteGameArenaResp")
	proto.RegisterType((*GameArena)(nil), "share.service.v1.GameArena")
	proto.RegisterType((*LoadGameAvoidInjuryReq)(nil), "share.service.v1.LoadGameAvoidInjuryReq")
	proto.RegisterType((*LoadGameAvoidInjuryResp)(nil), "share.service.v1.LoadGameAvoidInjuryResp")
	proto.RegisterMapType((map[string]*AvoidHurtMap)(nil), "share.service.v1.LoadGameAvoidInjuryResp.ProxyMapEntry")
	proto.RegisterType((*AvoidHurtMap)(nil), "share.service.v1.AvoidHurtMap")
	proto.RegisterMapType((map[string]*AvoidHurt)(nil), "share.service.v1.AvoidHurtMap.AvoidHurtMapEntry")
	proto.RegisterType((*AvoidHurt)(nil), "share.service.v1.AvoidHurt")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 1893 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xeb, 0x6e, 0x1b, 0xc7,
	0x15, 0xce, 0xf2, 0x62, 0x93, 0x47, 0xd4, 0x6d, 0x9c, 0xba, 0x0c, 0xad, 0x52, 0xf4, 0xc4, 0x06,
	0x9c, 0x02, 0xa1, 0x1d, 0xc7, 0x48, 0x5a, 0x07, 0x28, 0x22, 0x99, 0xb2, 0xc4, 0x50, 0x52, 0x94,
	0xa5, 0xe4, 0x16, 0x72, 0x11, 0x60, 0x25, 0x8e, 0x28, 0xc6, 0xe4, 0xee, 0x6a, 0x77, 0x29, 0x98,
	0x68, 0xfb, 0x08, 0xfd, 0x55, 0xa0, 0xe8, 0xff, 0x16, 0xe8, 0xab, 0x04, 0xe8, 0x9f, 0x3e, 0x41,
	0xd0, 0xba, 0x6f, 0x90, 0x27, 0x28, 0xe6, 0xb6, 0x3b, 0xcb, 0xbd, 0xd1, 0x0c, 0x11, 0xe4, 0xdf,
	0x9e, 0xb9, 0x7c, 0xe7, 0x9b, 0x33, 0xe7, 0x9c, 0x99, 0xb3, 0x03, 0x65, 0xc3, 0x1e, 0x34, 0x6d,
	0xc7, 0xf2, 0x2c, 0xb4, 0xe6, 0x5e, 0x1a, 0x0e, 0x69, 0xba, 0xc4, 0xb9, 0x1e, 0x9c, 0x93, 0xe6,
	0xf5, 0x47, 0xb5, 0x0f, 0xfb, 0x03, 0xef, 0x72, 0x7c, 0xd6, 0x3c, 0xb7, 0x46, 0x0f, 0xfb, 0x56,
	0xdf, 0x7a, 0xc8, 0x06, 0x9e, 0x8d, 0x2f, 0x98, 0xc4, 0x04, 0xf6, 0xc5, 0x01, 0x6a, 0x77, 0xfa,
	0x96, 0xd5, 0x1f, 0x92, 0x60, 0x14, 0x19, 0xd9, 0xde, 0x44, 0x74, 0x6e, 0x88, 0x4e, 0xc3, 0x1e,
	0x3c, 0x34, 0x4c, 0xd3, 0xf2, 0x0c, 0x6f, 0x60, 0x99, 0x2e, 0xef, 0xc5, 0x97, 0xb0, 0x76, 0xda,
	0x25, 0xde, 0xbe, 0x65, 0xf4, 0x74, 0xc3, 0xec, 0x13, 0x9d, 0x5c, 0x21, 0x04, 0x85, 0xe7, 0x8e,
	0x35, 0xaa, 0x6a, 0x0d, 0xed, 0x41, 0x51, 0x67, 0xdf, 0x68, 0x05, 0x72, 0xc7, 0x56, 0x35, 0xc7,
	0x5a, 0x72, 0xc7, 0x16, 0xaa, 0xc2, 0xcd, 0x2e, 0xf1, 0x0e, 0x8d, 0x11, 0xa9, 0xe6, 0x1b, 0xda,
	0x83, 0xb2, 0x2e, 0x45, 0x74, 0x1b, 0x6e, 0xec, 0x1a, 0x23, 0xd2, 0xee, 0x55, 0x0b, 0x6c, 0xb4,
	0x90, 0xf0, 0xa7, 0xb0, 0x4c, 0x35, 0x31, 0x2d, 0x2d, 0xc3, 0x33, 0xd0, 0x1a, 0xe4, 0x3b, 0x64,
	0xc2, 0xb4, 0x94, 0x75, 0xfa, 0x89, 0xde, 0x85, 0x62, 0xf7, 0xdc, 0x72, 0x08, 0xd3, 0x93, 0xd7,
	0xb9, 0x80, 0xf7, 0x60, 0x7d, 0x8a, 0xa2, 0x6b, 0xa3, 0x8f, 0xa1, 0xa0, 0x1b, 0xe6, 0xab, 0xaa,
	0xd6, 0xc8, 0x3f, 0x58, 0x7a, 0xbc, 0xd9, 0x9c, 0x36, 0x61, 0x33, 0xa4, 0x4b, 0x67, 0x83, 0xf1,
	0x01, 0xdc, 0x64, 0xcd, 0xe4, 0x4a, 0xe5, 0xaf, 0x85, 0xf9, 0x0b, 0x5a, 0xb9, 0x80, 0x56, 0xb0,
	0xa2, 0x7c, 0x68, 0x45, 0x9f, 0x73, 0xdb, 0xed, 0x12, 0x8f, 0x11, 0x65, 0xbc, 0xfc, 0x25, 0x68,
	0xca, 0x12, 0x14, 0x84, 0x5c, 0x08, 0xc1, 0x04, 0x44, 0x11, 0x4e, 0xec, 0x9e, 0xe1, 0x11, 0x01,
	0x72, 0x95, 0x80, 0xa1, 0x30, 0xce, 0xc5, 0x32, 0xce, 0xc7, 0x31, 0x0e, 0xef, 0xc1, 0x01, 0xac,
	0x0a, 0xc6, 0xd4, 0x1e, 0x8c, 0xf0, 0x8c, 0xbb, 0x40, 0x9d, 0x82, 0x19, 0x3c, 0xcf, 0x1a, 0xb9,
	0x3d, 0x05, 0x7d, 0x9d, 0x5c, 0x38, 0xc4, 0xbd, 0xe4, 0x90, 0x8c, 0x7e, 0x8b, 0x0c, 0x3d, 0x43,
	0xd2, 0x67, 0xc2, 0x42, 0xe8, 0xf7, 0xa0, 0xb4, 0xb7, 0x3f, 0x70, 0x3d, 0xe1, 0xa4, 0x6d, 0x8f,
	0x8c, 0x04, 0x71, 0xf6, 0x1d, 0xb3, 0x75, 0x35, 0x28, 0xd1, 0x09, 0x8a, 0x9f, 0xfa, 0x72, 0xa2,
	0x96, 0xfb, 0xb0, 0xcc, 0xb4, 0x30, 0x87, 0x13, 0x7b, 0x4a, 0xe1, 0x5d, 0xe6, 0x6c, 0x65, 0x9d,
	0x0b, 0xf8, 0x4f, 0xb0, 0x1e, 0x0c, 0x7b, 0x9b, 0xd0, 0x89, 0xae, 0x57, 0x65, 0x59, 0x48, 0x64,
	0x59, 0x0c, 0xb1, 0xbc, 0x07, 0x15, 0xa6, 0xfe, 0xc8, 0xb2, 0x25, 0xc9, 0x17, 0xc6, 0x70, 0x2c,
	0xdd, 0x99, 0x0b, 0xb8, 0x02, 0xf0, 0xcc, 0x1a, 0x8d, 0x2c, 0x93, 0x8e, 0xc1, 0x7f, 0x84, 0x52,
	0x87, 0x4c, 0x58, 0x0f, 0x7a, 0xa2, 0xec, 0xfb, 0x36, 0xfe, 0xfe, 0xbb, 0xcd, 0xfa, 0x85, 0xe5,
	0x8c, 0x9e, 0xe2, 0x0e, 0x99, 0xe0, 0xc6, 0xb5, 0x31, 0x1c, 0x50, 0x97, 0x7c, 0x8a, 0x1d, 0x72,
	0x35, 0x1e, 0x38, 0xa4, 0x87, 0x39, 0xd3, 0xa7, 0x50, 0xbc, 0x66, 0x5a, 0x98, 0x8d, 0xb7, 0xef,
	0x7d, 0xff, 0xdd, 0x66, 0x83, 0xcf, 0x63, 0xcd, 0xf1, 0x33, 0xf9, 0x14, 0xfc, 0x35, 0x20, 0xee,
	0xe8, 0x92, 0x83, 0x4b, 0x2d, 0x26, 0xd7, 0xd7, 0x12, 0x36, 0x13, 0x12, 0x7a, 0x24, 0x8d, 0x9e,
	0x63, 0x11, 0x5e, 0x8b, 0x46, 0xb8, 0x84, 0x91, 0x1b, 0xf2, 0x19, 0x2c, 0xd3, 0xbd, 0xc8, 0x86,
	0x46, 0x50, 0xe8, 0x90, 0x09, 0x47, 0x2e, 0xeb, 0xec, 0x1b, 0x6f, 0xc3, 0x8a, 0x3a, 0xd9, 0xb5,
	0x03, 0x02, 0xda, 0xac, 0x04, 0x9e, 0x40, 0xa5, 0x4b, 0xbc, 0x9d, 0xd7, 0xf6, 0x80, 0xc7, 0x71,
	0x34, 0xb4, 0x10, 0x14, 0x8e, 0x07, 0x23, 0x19, 0x59, 0xec, 0x1b, 0xdf, 0xe5, 0xb4, 0x53, 0xa6,
	0xe1, 0x4f, 0x38, 0x39, 0x39, 0x24, 0x36, 0x6a, 0xe3, 0xa0, 0xff, 0xae, 0xc1, 0x6a, 0xdb, 0x3c,
	0x77, 0xe8, 0xba, 0x59, 0x1a, 0x54, 0x8c, 0xd2, 0x0b, 0x19, 0xa5, 0x47, 0xe3, 0x73, 0xd7, 0xb1,
	0xc6, 0xb6, 0x9f, 0xa3, 0xa4, 0x18, 0xe3, 0xaf, 0xbe, 0xaf, 0x15, 0x78, 0x84, 0x73, 0x8f, 0xaa,
	0x41, 0x69, 0xcf, 0x70, 0x2f, 0x99, 0x17, 0x17, 0xb9, 0x17, 0x4b, 0x99, 0xf6, 0x75, 0x89, 0x73,
	0x4d, 0x9c, 0x76, 0xaf, 0x7a, 0x83, 0xf7, 0x49, 0x19, 0xff, 0x59, 0x83, 0x55, 0xba, 0xbc, 0x45,
	0xb3, 0x54, 0xf9, 0x14, 0x52, 0xf8, 0x14, 0xa7, 0xf8, 0xfc, 0x43, 0x83, 0xb5, 0x30, 0x1f, 0xd7,
	0xfe, 0x09, 0x9a, 0xed, 0x10, 0x6e, 0x88, 0xb3, 0x2c, 0x85, 0x5b, 0x42, 0xca, 0x95, 0xc9, 0x33,
	0x1f, 0x24, 0x4f, 0xfc, 0x4b, 0x58, 0xe9, 0x12, 0xef, 0x80, 0x8c, 0xce, 0x88, 0xc3, 0x23, 0xa0,
	0x0a, 0x37, 0x85, 0x28, 0x32, 0x9f, 0x14, 0xf1, 0x0b, 0xe6, 0xe9, 0xba, 0x61, 0xf6, 0xac, 0xd1,
	0x7c, 0x0c, 0xde, 0x85, 0xe2, 0x33, 0x6b, 0x6c, 0x7a, 0xe2, 0x3c, 0xe1, 0x02, 0xfe, 0x00, 0x96,
	0x15, 0xdc, 0x54, 0x0a, 0x1f, 0xc2, 0x6a, 0x97, 0x78, 0x6d, 0x97, 0xcb, 0x6c, 0x70, 0x0d, 0x4a,
	0x52, 0x66, 0x3c, 0x4a, 0xba, 0x2f, 0x63, 0x17, 0x96, 0xf7, 0xfc, 0x93, 0x96, 0x52, 0x6e, 0x2a,
	0xe7, 0x47, 0x7a, 0x74, 0xf3, 0xb3, 0x45, 0xdd, 0xa6, 0xdc, 0xd4, 0x36, 0x25, 0x5d, 0x10, 0xba,
	0xb0, 0xb4, 0x27, 0x6f, 0x2e, 0xb1, 0xf9, 0x60, 0x1e, 0xd0, 0xdf, 0x40, 0x25, 0x00, 0x75, 0xed,
	0xb7, 0x5d, 0x08, 0xd6, 0x01, 0xe8, 0xfc, 0x16, 0x19, 0x2e, 0x8e, 0xd3, 0x1f, 0xe0, 0x56, 0x60,
	0xdd, 0x20, 0x01, 0xbf, 0x75, 0x0a, 0x9d, 0x4b, 0xf9, 0x4b, 0x58, 0x97, 0x06, 0x09, 0x54, 0xcb,
	0x1c, 0xaf, 0x05, 0x39, 0x7e, 0x2e, 0xf0, 0xe7, 0x80, 0xa6, 0xc1, 0xe7, 0x3a, 0x1b, 0x4e, 0x61,
	0x4d, 0x58, 0x7d, 0xf1, 0x1c, 0x5b, 0xb0, 0x22, 0xb0, 0xe9, 0x50, 0x8a, 0xac, 0xa2, 0x68, 0x89,
	0x28, 0xe1, 0xbb, 0xa8, 0xcd, 0xfd, 0x62, 0xab, 0xd7, 0xfb, 0xb1, 0xc2, 0xe3, 0x8a, 0x87, 0x07,
	0x3d, 0xa1, 0x7e, 0x2c, 0x95, 0x5f, 0xca, 0x3b, 0x08, 0x95, 0xb7, 0x1c, 0x62, 0xb2, 0xd3, 0xe6,
	0xd7, 0x50, 0xf6, 0x65, 0xa1, 0xfe, 0x4e, 0x54, 0x7d, 0x30, 0x25, 0x18, 0x8d, 0x7f, 0x06, 0xb7,
	0x22, 0x80, 0xae, 0x8d, 0xd7, 0x61, 0x75, 0x97, 0x78, 0xaa, 0x12, 0x3c, 0x82, 0xb5, 0x70, 0x93,
	0x6b, 0xa3, 0xcf, 0x00, 0xfc, 0x06, 0xe9, 0x4c, 0xa9, 0x9a, 0x95, 0xe1, 0x68, 0x03, 0xca, 0xf4,
	0x94, 0xef, 0x7a, 0xc6, 0xc8, 0x16, 0xc7, 0x7e, 0xd0, 0x40, 0x57, 0xda, 0x22, 0x43, 0xb2, 0xd0,
	0x95, 0x46, 0x00, 0x5d, 0x1b, 0xff, 0x45, 0x53, 0x20, 0xe7, 0x38, 0x26, 0x37, 0xa0, 0xcc, 0xa6,
	0xb6, 0xcd, 0x0b, 0x4b, 0x9c, 0x47, 0x41, 0x03, 0xed, 0xdd, 0x79, 0xed, 0x39, 0x06, 0x3d, 0x87,
	0xc5, 0x21, 0x1e, 0x34, 0xb0, 0xd3, 0xc1, 0xf0, 0xce, 0x2f, 0xfd, 0xcb, 0xb1, 0x14, 0xf1, 0x23,
	0xb8, 0x2d, 0x8f, 0xf0, 0xad, 0x6b, 0x6b, 0xd0, 0x6b, 0x9b, 0xdf, 0x8c, 0x9d, 0x89, 0x38, 0xaa,
	0xfa, 0x01, 0xc3, 0xbc, 0x2e, 0x24, 0xfc, 0x2f, 0x0d, 0x7e, 0x1e, 0x3b, 0xc5, 0xb5, 0x51, 0x17,
	0x4a, 0xb6, 0x63, 0xbd, 0x9e, 0x1c, 0x18, 0xb6, 0xd8, 0xa4, 0x4f, 0xa3, 0x46, 0x4b, 0x98, 0xdc,
	0x3c, 0x12, 0x33, 0x77, 0x4c, 0xcf, 0x99, 0xe8, 0x3e, 0x50, 0xed, 0x25, 0x2c, 0x87, 0xba, 0x68,
	0x2a, 0x7e, 0x15, 0xa4, 0xe2, 0x57, 0x64, 0x82, 0x9e, 0xa8, 0xb7, 0xed, 0xa5, 0xc7, 0xf5, 0xa8,
	0x52, 0xa6, 0x6c, 0x6f, 0xec, 0x78, 0x07, 0x86, 0x2d, 0xee, 0xd9, 0x4f, 0x73, 0xbf, 0xd2, 0xf0,
	0x5f, 0x73, 0x50, 0x51, 0xfb, 0x92, 0x96, 0x4d, 0x73, 0x90, 0x19, 0x04, 0x10, 0xfb, 0xa6, 0x6d,
	0x3d, 0xe2, 0x9e, 0xcb, 0xdb, 0x01, 0xfd, 0xa6, 0x6d, 0xde, 0xc4, 0x96, 0x57, 0x17, 0xf6, 0x8d,
	0x8e, 0xa1, 0x62, 0x28, 0x3a, 0xaa, 0xc0, 0x4c, 0xf3, 0x28, 0x9d, 0x65, 0x48, 0xe0, 0x36, 0x09,
	0xa1, 0xd4, 0x7e, 0x0f, 0xeb, 0x91, 0x21, 0x31, 0xb6, 0xf9, 0x28, 0x6c, 0x9b, 0x3b, 0x29, 0x5a,
	0x55, 0xc3, 0x74, 0xa0, 0xec, 0xb7, 0xd3, 0x45, 0x0d, 0xc9, 0x85, 0x27, 0x4c, 0xc2, 0xbe, 0xe9,
	0xc5, 0xc4, 0x19, 0xf4, 0x2f, 0x3d, 0x59, 0xfd, 0x32, 0x81, 0xb6, 0x12, 0xea, 0x76, 0xf2, 0xba,
	0xc2, 0x84, 0xc7, 0xff, 0xbc, 0x03, 0x45, 0xa6, 0x16, 0x7d, 0x02, 0x85, 0xa3, 0x81, 0xd9, 0x47,
	0xb7, 0x9b, 0xfc, 0x6f, 0x4b, 0x53, 0xfe, 0x8a, 0x69, 0xee, 0x8c, 0x6c, 0x6f, 0x52, 0x4b, 0x68,
	0x47, 0x5f, 0xc1, 0x92, 0x28, 0xfe, 0x19, 0xcc, 0xbd, 0xe8, 0x2a, 0xa2, 0x25, 0x53, 0x6d, 0x23,
	0x3a, 0x2a, 0x28, 0xf2, 0xd0, 0x21, 0x94, 0xa9, 0x2b, 0x72, 0xc0, 0xcd, 0x78, 0x3f, 0x0d, 0xb0,
	0x1a, 0xe9, 0x03, 0x5c, 0x1b, 0x7d, 0x0d, 0xab, 0x53, 0x19, 0x2e, 0x99, 0xa6, 0x9a, 0x6b, 0x6a,
	0xf7, 0x67, 0x18, 0xc5, 0xf1, 0xa7, 0xf2, 0x4a, 0x1c, 0x7e, 0x34, 0x97, 0xc5, 0xe1, 0xc7, 0x24,
	0x28, 0xf4, 0x0d, 0xdc, 0x8a, 0x09, 0x4d, 0xf4, 0x60, 0xc6, 0x08, 0xbe, 0xaa, 0x7d, 0x30, 0x73,
	0xac, 0xa3, 0x13, 0x69, 0x2b, 0x7f, 0xbf, 0x16, 0xb2, 0xa5, 0x5f, 0x02, 0x04, 0x9b, 0xb2, 0x88,
	0x3d, 0x6d, 0x43, 0xd9, 0xaf, 0x54, 0x51, 0x4c, 0x5a, 0x51, 0xcb, 0xd8, 0xd9, 0xb8, 0x09, 0xac,
	0x04, 0x6e, 0x01, 0x58, 0x23, 0x7d, 0x00, 0x03, 0xac, 0xa8, 0x35, 0x2b, 0xba, 0x1b, 0x9d, 0x31,
	0x55, 0xd3, 0x66, 0x30, 0x3c, 0x81, 0x8a, 0x5a, 0xce, 0xc5, 0x01, 0x4e, 0x95, 0x9f, 0x35, 0x9c,
	0x35, 0xc4, 0xb5, 0xd1, 0xe7, 0xac, 0xfe, 0xda, 0xea, 0xf5, 0x50, 0x35, 0xd6, 0x80, 0xd9, 0xc4,
	0x38, 0x42, 0x8b, 0x0c, 0xe7, 0x46, 0xd8, 0x03, 0x08, 0x6a, 0xb6, 0x14, 0x94, 0x46, 0x6c, 0x8f,
	0x5a, 0xeb, 0xed, 0x33, 0x8f, 0xe0, 0x95, 0x57, 0x82, 0x47, 0xf8, 0xe5, 0x5e, 0x6d, 0x33, 0xb5,
	0xdf, 0xb5, 0xd1, 0x17, 0xb0, 0xa4, 0x14, 0x67, 0x29, 0xc4, 0xee, 0xc6, 0xf6, 0x84, 0xaa, 0xba,
	0x67, 0x8c, 0x59, 0x8b, 0x0c, 0xb7, 0x86, 0xf3, 0x1b, 0xaa, 0xc3, 0x2f, 0xb7, 0x3c, 0xf2, 0xe2,
	0xbc, 0x34, 0x54, 0x1c, 0x66, 0x80, 0xb5, 0xa1, 0x24, 0x6b, 0x02, 0xf4, 0x8b, 0x78, 0x28, 0x51,
	0xf2, 0xd5, 0xea, 0x69, 0xdd, 0xae, 0x8d, 0x76, 0xe0, 0xa6, 0xb8, 0xba, 0xa3, 0x8d, 0xf8, 0xa1,
	0xbc, 0x4e, 0xcb, 0x60, 0xf4, 0x5b, 0x5e, 0x5d, 0xa8, 0xf5, 0x17, 0xba, 0x9f, 0xb6, 0xc8, 0x59,
	0x33, 0xcf, 0x4b, 0x5e, 0x5a, 0x28, 0xd9, 0xe7, 0xfd, 0xe4, 0x15, 0x05, 0xa0, 0xf7, 0xb2, 0x07,
	0xb9, 0x36, 0xfa, 0x8a, 0xd7, 0xe4, 0x7e, 0x4d, 0x84, 0x70, 0xa2, 0x09, 0x66, 0xe5, 0x7b, 0xc0,
	0x4b, 0x0a, 0x51, 0x0a, 0xa1, 0x46, 0x22, 0xa0, 0xa8, 0x94, 0x32, 0xe0, 0xc4, 0xf6, 0xd0, 0x20,
	0x4f, 0xd8, 0x1e, 0x5e, 0x2e, 0x65, 0xc0, 0xec, 0x72, 0x87, 0xa1, 0x69, 0x2b, 0xc9, 0x61, 0x44,
	0x11, 0x94, 0x01, 0xd4, 0x12, 0x3f, 0xc0, 0x29, 0xa1, 0x98, 0x02, 0x49, 0xfe, 0x1c, 0xcf, 0xcc,
	0x1a, 0x15, 0x89, 0xb2, 0x6f, 0xb8, 0xde, 0x0f, 0x40, 0x92, 0x7c, 0xa8, 0xff, 0xce, 0x8f, 0xb2,
	0x0b, 0x4b, 0x12, 0x85, 0xc6, 0xf8, 0xfc, 0x40, 0x1d, 0xb1, 0x30, 0xea, 0x67, 0x59, 0x48, 0x9b,
	0x09, 0x7d, 0x7e, 0x68, 0xbe, 0x80, 0x95, 0xf0, 0xff, 0xfd, 0x58, 0xd7, 0x9f, 0x7e, 0x01, 0xc8,
	0xc6, 0xed, 0x88, 0xe7, 0x85, 0x23, 0xcb, 0x7e, 0x3e, 0x70, 0x32, 0xcc, 0x5f, 0x4f, 0xe8, 0x93,
	0x7f, 0xfd, 0xbf, 0x08, 0x5e, 0x01, 0x32, 0xb7, 0x32, 0x0b, 0xeb, 0x77, 0xfc, 0x81, 0x2e, 0x58,
	0x2f, 0x8e, 0x7f, 0x55, 0x0b, 0x2d, 0xf7, 0xfd, 0xcc, 0x31, 0x2c, 0x8b, 0x04, 0x8f, 0x8c, 0xe4,
	0x7a, 0xc1, 0xe0, 0x07, 0x50, 0x51, 0x5f, 0xe1, 0xd0, 0x7b, 0x09, 0x6f, 0x81, 0xf1, 0xc7, 0x7a,
	0xe4, 0x01, 0xef, 0x84, 0x3f, 0x91, 0x29, 0x4f, 0x72, 0x71, 0x57, 0xb8, 0xe8, 0xab, 0x5d, 0x86,
	0x6b, 0x6e, 0xf3, 0xa7, 0x47, 0x1a, 0x28, 0x29, 0x04, 0xb3, 0xb2, 0x11, 0x9c, 0x06, 0x47, 0xe1,
	0xdc, 0x30, 0x1d, 0x58, 0x52, 0x1e, 0x01, 0xd3, 0x70, 0xee, 0x26, 0xda, 0xcb, 0x7f, 0x3e, 0x3c,
	0x84, 0x15, 0xd9, 0xc4, 0x76, 0xf6, 0x87, 0xe2, 0x09, 0xf3, 0x2b, 0x4f, 0x8a, 0x49, 0xe6, 0x0f,
	0xbf, 0x3a, 0xa6, 0xaf, 0x79, 0xfb, 0xbd, 0x6f, 0xff, 0x5b, 0x7f, 0xe7, 0xdb, 0x37, 0x75, 0xed,
	0xdf, 0x6f, 0xea, 0xda, 0x7f, 0xde, 0xd4, 0xb5, 0xbf, 0xfd, 0xaf, 0xfe, 0xce, 0x69, 0xde, 0xb0,
	0x07, 0x67, 0x37, 0x58, 0x49, 0xf6, 0xf1, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x07, 0x31, 0x55,
	0x8b, 0x91, 0x1f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ShareClient is the client API for Share service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ShareClient interface {
	Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// 共享数据
	UpdateShare(ctx context.Context, in *UpdateKeyValuesReq, opts ...grpc.CallOption) (*CommonResp, error)
	LoadShare(ctx context.Context, in *LoadValuesReq, opts ...grpc.CallOption) (*LoadValuesResp, error)
	UpdateGameArena(ctx context.Context, in *UpdateGameArenaReq, opts ...grpc.CallOption) (*UpdateGameArenaResp, error)
	DeleteGameArena(ctx context.Context, in *DeleteGameArenaReq, opts ...grpc.CallOption) (*DeleteGameArenaResp, error)
	LoadGameAvoidInjury(ctx context.Context, in *LoadGameAvoidInjuryReq, opts ...grpc.CallOption) (*LoadGameAvoidInjuryResp, error)
	UpdateKeyValues(ctx context.Context, in *UpdateKeyValuesReq, opts ...grpc.CallOption) (*CommonResp, error)
	LoadValues(ctx context.Context, in *LoadValuesReq, opts ...grpc.CallOption) (*LoadValuesResp, error)
	SetExpire(ctx context.Context, in *SetExpireReq, opts ...grpc.CallOption) (*CommonResp, error)
	LoadExpire(ctx context.Context, in *LoadExpireReq, opts ...grpc.CallOption) (*LoadExpireResp, error)
	// redis
	IncrGameData(ctx context.Context, in *IncrGameDataReq, opts ...grpc.CallOption) (*CommonResp, error)
	LoadGameData(ctx context.Context, in *LoadGameDataReq, opts ...grpc.CallOption) (*LoadGameDataResp, error)
	SetAdd(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*CommonResp, error)
	SetDel(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*CommonResp, error)
	SetMembers(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetMembersResp, error)
	SetRandom(ctx context.Context, in *SetRandomReq, opts ...grpc.CallOption) (*SetRandomResp, error)
	SetIsMember(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetIsMemberResp, error)
	SetDelAll(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*CommonResp, error)
	HSetUpdate(ctx context.Context, in *HSetUpdateReq, opts ...grpc.CallOption) (*CommonResp, error)
	HSetLoad(ctx context.Context, in *HSetLoadReq, opts ...grpc.CallOption) (*HSetLoadResp, error)
	HSetDel(ctx context.Context, in *HSetDelReq, opts ...grpc.CallOption) (*CommonResp, error)
	HSetUpdateValues(ctx context.Context, in *HSetUpdateValuesReq, opts ...grpc.CallOption) (*CommonResp, error)
	HSetLoadValues(ctx context.Context, in *HSetLoadValuesReq, opts ...grpc.CallOption) (*HSetLoadValuesResp, error)
	HSetDelValues(ctx context.Context, in *HSetDelValuesReq, opts ...grpc.CallOption) (*CommonResp, error)
	HSetDelHash(ctx context.Context, in *HSetDelHashReq, opts ...grpc.CallOption) (*CommonResp, error)
	HSetAdd(ctx context.Context, in *HSetAddReq, opts ...grpc.CallOption) (*CommonResp, error)
	HSetIncr(ctx context.Context, in *HSetIncrReq, opts ...grpc.CallOption) (*CommonResp, error)
	HListAdd(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error)
	HListAddLast(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error)
	HListDel(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error)
	HListDelAll(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error)
	HListLoadAll(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*HListLoadResp, error)
	HListLoadRange(ctx context.Context, in *HListLoadRangeReq, opts ...grpc.CallOption) (*HListLoadResp, error)
	HListPopFirst(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*HListPopResp, error)
	HListPopLast(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*HListPopResp, error)
	ZSetLoadRange(ctx context.Context, in *ZSetLoadRangeReq, opts ...grpc.CallOption) (*ZSetLoadRangeResp, error)
	ZSetLoadRevRange(ctx context.Context, in *ZSetLoadRangeReq, opts ...grpc.CallOption) (*ZSetLoadRangeResp, error)
	ZSetGetScore(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*ZSetGetScoreResp, error)
	ZSetUpdateScore(ctx context.Context, in *ZSetUpdateScoreReq, opts ...grpc.CallOption) (*CommonResp, error)
	ZSetDel(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*CommonResp, error)
	ZSetDelAll(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*CommonResp, error)
	ZSetGetRank(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*ZSetGetRankResp, error)
	ZSetGetRevRank(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*ZSetGetRankResp, error)
	ZSetRefreshRank(ctx context.Context, in *ZSetRefreshRankReq, opts ...grpc.CallOption) (*CommonResp, error)
}

type shareClient struct {
	cc *grpc.ClientConn
}

func NewShareClient(cc *grpc.ClientConn) ShareClient {
	return &shareClient{cc}
}

func (c *shareClient) Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UpdateShare(ctx context.Context, in *UpdateKeyValuesReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/UpdateShare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) LoadShare(ctx context.Context, in *LoadValuesReq, opts ...grpc.CallOption) (*LoadValuesResp, error) {
	out := new(LoadValuesResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/LoadShare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UpdateGameArena(ctx context.Context, in *UpdateGameArenaReq, opts ...grpc.CallOption) (*UpdateGameArenaResp, error) {
	out := new(UpdateGameArenaResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/UpdateGameArena", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) DeleteGameArena(ctx context.Context, in *DeleteGameArenaReq, opts ...grpc.CallOption) (*DeleteGameArenaResp, error) {
	out := new(DeleteGameArenaResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/DeleteGameArena", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) LoadGameAvoidInjury(ctx context.Context, in *LoadGameAvoidInjuryReq, opts ...grpc.CallOption) (*LoadGameAvoidInjuryResp, error) {
	out := new(LoadGameAvoidInjuryResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/LoadGameAvoidInjury", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UpdateKeyValues(ctx context.Context, in *UpdateKeyValuesReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/UpdateKeyValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) LoadValues(ctx context.Context, in *LoadValuesReq, opts ...grpc.CallOption) (*LoadValuesResp, error) {
	out := new(LoadValuesResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/LoadValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) SetExpire(ctx context.Context, in *SetExpireReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/SetExpire", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) LoadExpire(ctx context.Context, in *LoadExpireReq, opts ...grpc.CallOption) (*LoadExpireResp, error) {
	out := new(LoadExpireResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/LoadExpire", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) IncrGameData(ctx context.Context, in *IncrGameDataReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/IncrGameData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) LoadGameData(ctx context.Context, in *LoadGameDataReq, opts ...grpc.CallOption) (*LoadGameDataResp, error) {
	out := new(LoadGameDataResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/LoadGameData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) SetAdd(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/SetAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) SetDel(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/SetDel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) SetMembers(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetMembersResp, error) {
	out := new(SetMembersResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/SetMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) SetRandom(ctx context.Context, in *SetRandomReq, opts ...grpc.CallOption) (*SetRandomResp, error) {
	out := new(SetRandomResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/SetRandom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) SetIsMember(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetIsMemberResp, error) {
	out := new(SetIsMemberResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/SetIsMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) SetDelAll(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/SetDelAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetUpdate(ctx context.Context, in *HSetUpdateReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetLoad(ctx context.Context, in *HSetLoadReq, opts ...grpc.CallOption) (*HSetLoadResp, error) {
	out := new(HSetLoadResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetLoad", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetDel(ctx context.Context, in *HSetDelReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetDel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetUpdateValues(ctx context.Context, in *HSetUpdateValuesReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetUpdateValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetLoadValues(ctx context.Context, in *HSetLoadValuesReq, opts ...grpc.CallOption) (*HSetLoadValuesResp, error) {
	out := new(HSetLoadValuesResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetLoadValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetDelValues(ctx context.Context, in *HSetDelValuesReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetDelValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetDelHash(ctx context.Context, in *HSetDelHashReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetDelHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetAdd(ctx context.Context, in *HSetAddReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HSetIncr(ctx context.Context, in *HSetIncrReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HSetIncr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListAdd(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListAddLast(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListAddLast", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListDel(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListDel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListDelAll(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListDelAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListLoadAll(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*HListLoadResp, error) {
	out := new(HListLoadResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListLoadAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListLoadRange(ctx context.Context, in *HListLoadRangeReq, opts ...grpc.CallOption) (*HListLoadResp, error) {
	out := new(HListLoadResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListLoadRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListPopFirst(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*HListPopResp, error) {
	out := new(HListPopResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListPopFirst", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) HListPopLast(ctx context.Context, in *HListReq, opts ...grpc.CallOption) (*HListPopResp, error) {
	out := new(HListPopResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/HListPopLast", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetLoadRange(ctx context.Context, in *ZSetLoadRangeReq, opts ...grpc.CallOption) (*ZSetLoadRangeResp, error) {
	out := new(ZSetLoadRangeResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetLoadRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetLoadRevRange(ctx context.Context, in *ZSetLoadRangeReq, opts ...grpc.CallOption) (*ZSetLoadRangeResp, error) {
	out := new(ZSetLoadRangeResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetLoadRevRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetGetScore(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*ZSetGetScoreResp, error) {
	out := new(ZSetGetScoreResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetGetScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetUpdateScore(ctx context.Context, in *ZSetUpdateScoreReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetUpdateScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetDel(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetDel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetDelAll(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetDelAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetGetRank(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*ZSetGetRankResp, error) {
	out := new(ZSetGetRankResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetGetRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetGetRevRank(ctx context.Context, in *ZSetReq, opts ...grpc.CallOption) (*ZSetGetRankResp, error) {
	out := new(ZSetGetRankResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetGetRevRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ZSetRefreshRank(ctx context.Context, in *ZSetRefreshRankReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := c.cc.Invoke(ctx, "/share.service.v1.share/ZSetRefreshRank", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShareServer is the server API for Share service.
type ShareServer interface {
	Ping(context.Context, *empty.Empty) (*empty.Empty, error)
	// 共享数据
	UpdateShare(context.Context, *UpdateKeyValuesReq) (*CommonResp, error)
	LoadShare(context.Context, *LoadValuesReq) (*LoadValuesResp, error)
	UpdateGameArena(context.Context, *UpdateGameArenaReq) (*UpdateGameArenaResp, error)
	DeleteGameArena(context.Context, *DeleteGameArenaReq) (*DeleteGameArenaResp, error)
	LoadGameAvoidInjury(context.Context, *LoadGameAvoidInjuryReq) (*LoadGameAvoidInjuryResp, error)
	UpdateKeyValues(context.Context, *UpdateKeyValuesReq) (*CommonResp, error)
	LoadValues(context.Context, *LoadValuesReq) (*LoadValuesResp, error)
	SetExpire(context.Context, *SetExpireReq) (*CommonResp, error)
	LoadExpire(context.Context, *LoadExpireReq) (*LoadExpireResp, error)
	// redis
	IncrGameData(context.Context, *IncrGameDataReq) (*CommonResp, error)
	LoadGameData(context.Context, *LoadGameDataReq) (*LoadGameDataResp, error)
	SetAdd(context.Context, *SetReq) (*CommonResp, error)
	SetDel(context.Context, *SetReq) (*CommonResp, error)
	SetMembers(context.Context, *SetReq) (*SetMembersResp, error)
	SetRandom(context.Context, *SetRandomReq) (*SetRandomResp, error)
	SetIsMember(context.Context, *SetReq) (*SetIsMemberResp, error)
	SetDelAll(context.Context, *SetReq) (*CommonResp, error)
	HSetUpdate(context.Context, *HSetUpdateReq) (*CommonResp, error)
	HSetLoad(context.Context, *HSetLoadReq) (*HSetLoadResp, error)
	HSetDel(context.Context, *HSetDelReq) (*CommonResp, error)
	HSetUpdateValues(context.Context, *HSetUpdateValuesReq) (*CommonResp, error)
	HSetLoadValues(context.Context, *HSetLoadValuesReq) (*HSetLoadValuesResp, error)
	HSetDelValues(context.Context, *HSetDelValuesReq) (*CommonResp, error)
	HSetDelHash(context.Context, *HSetDelHashReq) (*CommonResp, error)
	HSetAdd(context.Context, *HSetAddReq) (*CommonResp, error)
	HSetIncr(context.Context, *HSetIncrReq) (*CommonResp, error)
	HListAdd(context.Context, *HListReq) (*CommonResp, error)
	HListAddLast(context.Context, *HListReq) (*CommonResp, error)
	HListDel(context.Context, *HListReq) (*CommonResp, error)
	HListDelAll(context.Context, *HListReq) (*CommonResp, error)
	HListLoadAll(context.Context, *HListReq) (*HListLoadResp, error)
	HListLoadRange(context.Context, *HListLoadRangeReq) (*HListLoadResp, error)
	HListPopFirst(context.Context, *HListReq) (*HListPopResp, error)
	HListPopLast(context.Context, *HListReq) (*HListPopResp, error)
	ZSetLoadRange(context.Context, *ZSetLoadRangeReq) (*ZSetLoadRangeResp, error)
	ZSetLoadRevRange(context.Context, *ZSetLoadRangeReq) (*ZSetLoadRangeResp, error)
	ZSetGetScore(context.Context, *ZSetReq) (*ZSetGetScoreResp, error)
	ZSetUpdateScore(context.Context, *ZSetUpdateScoreReq) (*CommonResp, error)
	ZSetDel(context.Context, *ZSetReq) (*CommonResp, error)
	ZSetDelAll(context.Context, *ZSetReq) (*CommonResp, error)
	ZSetGetRank(context.Context, *ZSetReq) (*ZSetGetRankResp, error)
	ZSetGetRevRank(context.Context, *ZSetReq) (*ZSetGetRankResp, error)
	ZSetRefreshRank(context.Context, *ZSetRefreshRankReq) (*CommonResp, error)
}

// UnimplementedShareServer can be embedded to have forward compatible implementations.
type UnimplementedShareServer struct {
}

func (*UnimplementedShareServer) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedShareServer) UpdateShare(ctx context.Context, req *UpdateKeyValuesReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShare not implemented")
}
func (*UnimplementedShareServer) LoadShare(ctx context.Context, req *LoadValuesReq) (*LoadValuesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadShare not implemented")
}
func (*UnimplementedShareServer) UpdateGameArena(ctx context.Context, req *UpdateGameArenaReq) (*UpdateGameArenaResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGameArena not implemented")
}
func (*UnimplementedShareServer) DeleteGameArena(ctx context.Context, req *DeleteGameArenaReq) (*DeleteGameArenaResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGameArena not implemented")
}
func (*UnimplementedShareServer) LoadGameAvoidInjury(ctx context.Context, req *LoadGameAvoidInjuryReq) (*LoadGameAvoidInjuryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadGameAvoidInjury not implemented")
}
func (*UnimplementedShareServer) UpdateKeyValues(ctx context.Context, req *UpdateKeyValuesReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKeyValues not implemented")
}
func (*UnimplementedShareServer) LoadValues(ctx context.Context, req *LoadValuesReq) (*LoadValuesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadValues not implemented")
}
func (*UnimplementedShareServer) SetExpire(ctx context.Context, req *SetExpireReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExpire not implemented")
}
func (*UnimplementedShareServer) LoadExpire(ctx context.Context, req *LoadExpireReq) (*LoadExpireResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadExpire not implemented")
}
func (*UnimplementedShareServer) IncrGameData(ctx context.Context, req *IncrGameDataReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrGameData not implemented")
}
func (*UnimplementedShareServer) LoadGameData(ctx context.Context, req *LoadGameDataReq) (*LoadGameDataResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadGameData not implemented")
}
func (*UnimplementedShareServer) SetAdd(ctx context.Context, req *SetReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAdd not implemented")
}
func (*UnimplementedShareServer) SetDel(ctx context.Context, req *SetReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDel not implemented")
}
func (*UnimplementedShareServer) SetMembers(ctx context.Context, req *SetReq) (*SetMembersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMembers not implemented")
}
func (*UnimplementedShareServer) SetRandom(ctx context.Context, req *SetRandomReq) (*SetRandomResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRandom not implemented")
}
func (*UnimplementedShareServer) SetIsMember(ctx context.Context, req *SetReq) (*SetIsMemberResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsMember not implemented")
}
func (*UnimplementedShareServer) SetDelAll(ctx context.Context, req *SetReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDelAll not implemented")
}
func (*UnimplementedShareServer) HSetUpdate(ctx context.Context, req *HSetUpdateReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetUpdate not implemented")
}
func (*UnimplementedShareServer) HSetLoad(ctx context.Context, req *HSetLoadReq) (*HSetLoadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetLoad not implemented")
}
func (*UnimplementedShareServer) HSetDel(ctx context.Context, req *HSetDelReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetDel not implemented")
}
func (*UnimplementedShareServer) HSetUpdateValues(ctx context.Context, req *HSetUpdateValuesReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetUpdateValues not implemented")
}
func (*UnimplementedShareServer) HSetLoadValues(ctx context.Context, req *HSetLoadValuesReq) (*HSetLoadValuesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetLoadValues not implemented")
}
func (*UnimplementedShareServer) HSetDelValues(ctx context.Context, req *HSetDelValuesReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetDelValues not implemented")
}
func (*UnimplementedShareServer) HSetDelHash(ctx context.Context, req *HSetDelHashReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetDelHash not implemented")
}
func (*UnimplementedShareServer) HSetAdd(ctx context.Context, req *HSetAddReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetAdd not implemented")
}
func (*UnimplementedShareServer) HSetIncr(ctx context.Context, req *HSetIncrReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HSetIncr not implemented")
}
func (*UnimplementedShareServer) HListAdd(ctx context.Context, req *HListReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListAdd not implemented")
}
func (*UnimplementedShareServer) HListAddLast(ctx context.Context, req *HListReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListAddLast not implemented")
}
func (*UnimplementedShareServer) HListDel(ctx context.Context, req *HListReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListDel not implemented")
}
func (*UnimplementedShareServer) HListDelAll(ctx context.Context, req *HListReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListDelAll not implemented")
}
func (*UnimplementedShareServer) HListLoadAll(ctx context.Context, req *HListReq) (*HListLoadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListLoadAll not implemented")
}
func (*UnimplementedShareServer) HListLoadRange(ctx context.Context, req *HListLoadRangeReq) (*HListLoadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListLoadRange not implemented")
}
func (*UnimplementedShareServer) HListPopFirst(ctx context.Context, req *HListReq) (*HListPopResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListPopFirst not implemented")
}
func (*UnimplementedShareServer) HListPopLast(ctx context.Context, req *HListReq) (*HListPopResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HListPopLast not implemented")
}
func (*UnimplementedShareServer) ZSetLoadRange(ctx context.Context, req *ZSetLoadRangeReq) (*ZSetLoadRangeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetLoadRange not implemented")
}
func (*UnimplementedShareServer) ZSetLoadRevRange(ctx context.Context, req *ZSetLoadRangeReq) (*ZSetLoadRangeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetLoadRevRange not implemented")
}
func (*UnimplementedShareServer) ZSetGetScore(ctx context.Context, req *ZSetReq) (*ZSetGetScoreResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetGetScore not implemented")
}
func (*UnimplementedShareServer) ZSetUpdateScore(ctx context.Context, req *ZSetUpdateScoreReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetUpdateScore not implemented")
}
func (*UnimplementedShareServer) ZSetDel(ctx context.Context, req *ZSetReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetDel not implemented")
}
func (*UnimplementedShareServer) ZSetDelAll(ctx context.Context, req *ZSetReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetDelAll not implemented")
}
func (*UnimplementedShareServer) ZSetGetRank(ctx context.Context, req *ZSetReq) (*ZSetGetRankResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetGetRank not implemented")
}
func (*UnimplementedShareServer) ZSetGetRevRank(ctx context.Context, req *ZSetReq) (*ZSetGetRankResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetGetRevRank not implemented")
}
func (*UnimplementedShareServer) ZSetRefreshRank(ctx context.Context, req *ZSetRefreshRankReq) (*CommonResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ZSetRefreshRank not implemented")
}

func RegisterShareServer(s *grpc.Server, srv ShareServer) {
	s.RegisterService(&_Share_serviceDesc, srv)
}

func _Share_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).Ping(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UpdateShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateKeyValuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UpdateShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/UpdateShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UpdateShare(ctx, req.(*UpdateKeyValuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_LoadShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadValuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).LoadShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/LoadShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).LoadShare(ctx, req.(*LoadValuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UpdateGameArena_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGameArenaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UpdateGameArena(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/UpdateGameArena",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UpdateGameArena(ctx, req.(*UpdateGameArenaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_DeleteGameArena_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGameArenaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).DeleteGameArena(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/DeleteGameArena",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).DeleteGameArena(ctx, req.(*DeleteGameArenaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_LoadGameAvoidInjury_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadGameAvoidInjuryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).LoadGameAvoidInjury(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/LoadGameAvoidInjury",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).LoadGameAvoidInjury(ctx, req.(*LoadGameAvoidInjuryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UpdateKeyValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateKeyValuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UpdateKeyValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/UpdateKeyValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UpdateKeyValues(ctx, req.(*UpdateKeyValuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_LoadValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadValuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).LoadValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/LoadValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).LoadValues(ctx, req.(*LoadValuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_SetExpire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetExpireReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).SetExpire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/SetExpire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).SetExpire(ctx, req.(*SetExpireReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_LoadExpire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadExpireReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).LoadExpire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/LoadExpire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).LoadExpire(ctx, req.(*LoadExpireReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_IncrGameData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrGameDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).IncrGameData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/IncrGameData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).IncrGameData(ctx, req.(*IncrGameDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_LoadGameData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadGameDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).LoadGameData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/LoadGameData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).LoadGameData(ctx, req.(*LoadGameDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_SetAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).SetAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/SetAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).SetAdd(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_SetDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).SetDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/SetDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).SetDel(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_SetMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).SetMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/SetMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).SetMembers(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_SetRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRandomReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).SetRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/SetRandom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).SetRandom(ctx, req.(*SetRandomReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_SetIsMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).SetIsMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/SetIsMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).SetIsMember(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_SetDelAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).SetDelAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/SetDelAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).SetDelAll(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetUpdate(ctx, req.(*HSetUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetLoad_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetLoadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetLoad(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetLoad",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetLoad(ctx, req.(*HSetLoadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetDelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetDel(ctx, req.(*HSetDelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetUpdateValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetUpdateValuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetUpdateValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetUpdateValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetUpdateValues(ctx, req.(*HSetUpdateValuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetLoadValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetLoadValuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetLoadValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetLoadValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetLoadValues(ctx, req.(*HSetLoadValuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetDelValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetDelValuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetDelValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetDelValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetDelValues(ctx, req.(*HSetDelValuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetDelHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetDelHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetDelHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetDelHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetDelHash(ctx, req.(*HSetDelHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetAddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetAdd(ctx, req.(*HSetAddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HSetIncr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetIncrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HSetIncr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HSetIncr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HSetIncr(ctx, req.(*HSetIncrReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListAdd(ctx, req.(*HListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListAddLast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListAddLast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListAddLast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListAddLast(ctx, req.(*HListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListDel(ctx, req.(*HListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListDelAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListDelAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListDelAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListDelAll(ctx, req.(*HListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListLoadAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListLoadAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListLoadAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListLoadAll(ctx, req.(*HListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListLoadRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListLoadRangeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListLoadRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListLoadRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListLoadRange(ctx, req.(*HListLoadRangeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListPopFirst_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListPopFirst(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListPopFirst",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListPopFirst(ctx, req.(*HListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_HListPopLast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).HListPopLast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/HListPopLast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).HListPopLast(ctx, req.(*HListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetLoadRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetLoadRangeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetLoadRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetLoadRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetLoadRange(ctx, req.(*ZSetLoadRangeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetLoadRevRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetLoadRangeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetLoadRevRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetLoadRevRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetLoadRevRange(ctx, req.(*ZSetLoadRangeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetGetScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetGetScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetGetScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetGetScore(ctx, req.(*ZSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetUpdateScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetUpdateScoreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetUpdateScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetUpdateScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetUpdateScore(ctx, req.(*ZSetUpdateScoreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetDel(ctx, req.(*ZSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetDelAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetDelAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetDelAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetDelAll(ctx, req.(*ZSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetGetRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetGetRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetGetRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetGetRank(ctx, req.(*ZSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetGetRevRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetGetRevRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetGetRevRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetGetRevRank(ctx, req.(*ZSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ZSetRefreshRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZSetRefreshRankReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).ZSetRefreshRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/share.service.v1.share/ZSetRefreshRank",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).ZSetRefreshRank(ctx, req.(*ZSetRefreshRankReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Share_serviceDesc = grpc.ServiceDesc{
	ServiceName: "share.service.v1.share",
	HandlerType: (*ShareServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Share_Ping_Handler,
		},
		{
			MethodName: "UpdateShare",
			Handler:    _Share_UpdateShare_Handler,
		},
		{
			MethodName: "LoadShare",
			Handler:    _Share_LoadShare_Handler,
		},
		{
			MethodName: "UpdateGameArena",
			Handler:    _Share_UpdateGameArena_Handler,
		},
		{
			MethodName: "DeleteGameArena",
			Handler:    _Share_DeleteGameArena_Handler,
		},
		{
			MethodName: "LoadGameAvoidInjury",
			Handler:    _Share_LoadGameAvoidInjury_Handler,
		},
		{
			MethodName: "UpdateKeyValues",
			Handler:    _Share_UpdateKeyValues_Handler,
		},
		{
			MethodName: "LoadValues",
			Handler:    _Share_LoadValues_Handler,
		},
		{
			MethodName: "SetExpire",
			Handler:    _Share_SetExpire_Handler,
		},
		{
			MethodName: "LoadExpire",
			Handler:    _Share_LoadExpire_Handler,
		},
		{
			MethodName: "IncrGameData",
			Handler:    _Share_IncrGameData_Handler,
		},
		{
			MethodName: "LoadGameData",
			Handler:    _Share_LoadGameData_Handler,
		},
		{
			MethodName: "SetAdd",
			Handler:    _Share_SetAdd_Handler,
		},
		{
			MethodName: "SetDel",
			Handler:    _Share_SetDel_Handler,
		},
		{
			MethodName: "SetMembers",
			Handler:    _Share_SetMembers_Handler,
		},
		{
			MethodName: "SetRandom",
			Handler:    _Share_SetRandom_Handler,
		},
		{
			MethodName: "SetIsMember",
			Handler:    _Share_SetIsMember_Handler,
		},
		{
			MethodName: "SetDelAll",
			Handler:    _Share_SetDelAll_Handler,
		},
		{
			MethodName: "HSetUpdate",
			Handler:    _Share_HSetUpdate_Handler,
		},
		{
			MethodName: "HSetLoad",
			Handler:    _Share_HSetLoad_Handler,
		},
		{
			MethodName: "HSetDel",
			Handler:    _Share_HSetDel_Handler,
		},
		{
			MethodName: "HSetUpdateValues",
			Handler:    _Share_HSetUpdateValues_Handler,
		},
		{
			MethodName: "HSetLoadValues",
			Handler:    _Share_HSetLoadValues_Handler,
		},
		{
			MethodName: "HSetDelValues",
			Handler:    _Share_HSetDelValues_Handler,
		},
		{
			MethodName: "HSetDelHash",
			Handler:    _Share_HSetDelHash_Handler,
		},
		{
			MethodName: "HSetAdd",
			Handler:    _Share_HSetAdd_Handler,
		},
		{
			MethodName: "HSetIncr",
			Handler:    _Share_HSetIncr_Handler,
		},
		{
			MethodName: "HListAdd",
			Handler:    _Share_HListAdd_Handler,
		},
		{
			MethodName: "HListAddLast",
			Handler:    _Share_HListAddLast_Handler,
		},
		{
			MethodName: "HListDel",
			Handler:    _Share_HListDel_Handler,
		},
		{
			MethodName: "HListDelAll",
			Handler:    _Share_HListDelAll_Handler,
		},
		{
			MethodName: "HListLoadAll",
			Handler:    _Share_HListLoadAll_Handler,
		},
		{
			MethodName: "HListLoadRange",
			Handler:    _Share_HListLoadRange_Handler,
		},
		{
			MethodName: "HListPopFirst",
			Handler:    _Share_HListPopFirst_Handler,
		},
		{
			MethodName: "HListPopLast",
			Handler:    _Share_HListPopLast_Handler,
		},
		{
			MethodName: "ZSetLoadRange",
			Handler:    _Share_ZSetLoadRange_Handler,
		},
		{
			MethodName: "ZSetLoadRevRange",
			Handler:    _Share_ZSetLoadRevRange_Handler,
		},
		{
			MethodName: "ZSetGetScore",
			Handler:    _Share_ZSetGetScore_Handler,
		},
		{
			MethodName: "ZSetUpdateScore",
			Handler:    _Share_ZSetUpdateScore_Handler,
		},
		{
			MethodName: "ZSetDel",
			Handler:    _Share_ZSetDel_Handler,
		},
		{
			MethodName: "ZSetDelAll",
			Handler:    _Share_ZSetDelAll_Handler,
		},
		{
			MethodName: "ZSetGetRank",
			Handler:    _Share_ZSetGetRank_Handler,
		},
		{
			MethodName: "ZSetGetRevRank",
			Handler:    _Share_ZSetGetRevRank_Handler,
		},
		{
			MethodName: "ZSetRefreshRank",
			Handler:    _Share_ZSetRefreshRank_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *ZSetLoadRangeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetLoadRangeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetLoadRangeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SetName) > 0 {
		i -= len(m.SetName)
		copy(dAtA[i:], m.SetName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.To != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZSetRangeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetRangeData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetRangeData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZSetLoadRangeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetLoadRangeResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetLoadRangeResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rank) > 0 {
		for iNdEx := len(m.Rank) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rank[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ZSetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SetName) > 0 {
		i -= len(m.SetName)
		copy(dAtA[i:], m.SetName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZSetGetScoreResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetGetScoreResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetGetScoreResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZSetUpdateScoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetUpdateScoreReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetUpdateScoreReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SetName) > 0 {
		i -= len(m.SetName)
		copy(dAtA[i:], m.SetName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZSetGetRankResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetGetRankResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetGetRankResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rank != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x18
	}
	if m.Score != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZSetRefreshRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZSetRefreshRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZSetRefreshRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SetName) > 0 {
		i -= len(m.SetName)
		copy(dAtA[i:], m.SetName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Delta != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Delta))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ListName) > 0 {
		i -= len(m.ListName)
		copy(dAtA[i:], m.ListName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ListName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Item) > 0 {
		i -= len(m.Item)
		copy(dAtA[i:], m.Item)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Item)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HListLoadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HListLoadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HListLoadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Items[iNdEx])
			copy(dAtA[i:], m.Items[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Items[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HListLoadRangeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HListLoadRangeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HListLoadRangeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ListName) > 0 {
		i -= len(m.ListName)
		copy(dAtA[i:], m.ListName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ListName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.To != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HListPopResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HListPopResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HListPopResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateKeyValuesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateKeyValuesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateKeyValuesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadValuesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadValuesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadValuesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GameID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadValuesResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadValuesResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadValuesResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetExpireReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetExpireReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetExpireReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoadExpireReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadExpireReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadExpireReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoadExpireResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadExpireResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadExpireResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IncrGameDataReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrGameDataReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrGameDataReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerId) > 0 {
		i -= len(m.ServerId)
		copy(dAtA[i:], m.ServerId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServerId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadGameDataReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadGameDataReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadGameDataReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerId) > 0 {
		i -= len(m.ServerId)
		copy(dAtA[i:], m.ServerId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServerId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadGameDataResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadGameDataResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadGameDataResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerId) > 0 {
		i -= len(m.ServerId)
		copy(dAtA[i:], m.ServerId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServerId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Item) > 0 {
		i -= len(m.Item)
		copy(dAtA[i:], m.Item)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Item)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SetName) > 0 {
		i -= len(m.SetName)
		copy(dAtA[i:], m.SetName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetName)))
		i--
		dAtA[i] = 0x12
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetMembersResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMembersResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetMembersResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetRandomReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRandomReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRandomReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SetName) > 0 {
		i -= len(m.SetName)
		copy(dAtA[i:], m.SetName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetName)))
		i--
		dAtA[i] = 0x12
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetRandomResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRandomResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRandomResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetIsMemberResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetIsMemberResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetIsMemberResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsMember {
		i--
		if m.IsMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HSetUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetUpdateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HSetLoadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetLoadReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetLoadReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HSetLoadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetLoadResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetLoadResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HSetDelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetDelReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetDelReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HSetUpdateValuesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetUpdateValuesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetUpdateValuesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HSetLoadValuesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetLoadValuesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetLoadValuesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HSetLoadValuesResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetLoadValuesResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetLoadValuesResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HSetDelValuesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetDelValuesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetDelValuesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HSetDelHashReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetDelHashReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetDelHashReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HSetAddReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetAddReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetAddReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HSetIncrReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HSetIncrReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HSetIncrReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HashName) > 0 {
		i -= len(m.HashName)
		copy(dAtA[i:], m.HashName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.HashName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGameArenaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGameArenaReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGameArenaReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameArena != nil {
		{
			size, err := m.GameArena.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGameArenaResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGameArenaResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGameArenaResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetGameArenaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGameArenaReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGameArenaReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetGameArenaResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGameArenaResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGameArenaResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TimeStamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TimeStamp))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GameArenas) > 0 {
		for iNdEx := len(m.GameArenas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GameArenas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteGameArenaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteGameArenaReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteGameArenaReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameArena != nil {
		{
			size, err := m.GameArena.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteGameArenaResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteGameArenaResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteGameArenaResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GameArena) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameArena) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameArena) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MatchId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExtraData) > 0 {
		i -= len(m.ExtraData)
		copy(dAtA[i:], m.ExtraData)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ExtraData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ArenaInfo) > 0 {
		i -= len(m.ArenaInfo)
		copy(dAtA[i:], m.ArenaInfo)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ArenaInfo)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadGameAvoidInjuryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadGameAvoidInjuryReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadGameAvoidInjuryReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadGameAvoidInjuryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadGameAvoidInjuryResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadGameAvoidInjuryResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyMap) > 0 {
		for k := range m.ProxyMap {
			v := m.ProxyMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AvoidHurtMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvoidHurtMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvoidHurtMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AvoidHurtMap) > 0 {
		for k := range m.AvoidHurtMap {
			v := m.AvoidHurtMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Type != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.GameId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AvoidHurt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvoidHurt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvoidHurt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Extra != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Extra))
		i--
		dAtA[i] = 0x18
	}
	if m.Right != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Right))
		i--
		dAtA[i] = 0x10
	}
	if m.Left != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Left))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ZSetLoadRangeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovApi(uint64(m.To))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZSetRangeData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZSetLoadRangeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rank) > 0 {
		for _, e := range m.Rank {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZSetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZSetGetScoreResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZSetUpdateScoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZSetGetRankResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZSetRefreshRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delta != 0 {
		n += 1 + sovApi(uint64(m.Delta))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Item)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ListName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HListLoadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, s := range m.Items {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HListLoadRangeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovApi(uint64(m.To))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ListName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HListPopResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateKeyValuesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadValuesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovApi(uint64(m.GameID))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadValuesResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetExpireReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovApi(uint64(m.Time))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadExpireReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadExpireResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovApi(uint64(m.Time))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IncrGameDataReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.GroupId != 0 {
		n += 1 + sovApi(uint64(m.GroupId))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovApi(uint64(m.Value))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadGameDataReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.GroupId != 0 {
		n += 1 + sovApi(uint64(m.GroupId))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadGameDataResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.GroupId != 0 {
		n += 1 + sovApi(uint64(m.GroupId))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovApi(uint64(m.Value))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Item)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetMembersResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetRandomReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetRandomResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetIsMemberResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsMember {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetLoadReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetLoadResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetDelReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetUpdateValuesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetLoadValuesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetLoadValuesResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetDelValuesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetDelHashReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetAddReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HSetIncrReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HashName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateGameArenaReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameArena != nil {
		l = m.GameArena.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateGameArenaResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGameArenaReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGameArenaResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GameArenas) > 0 {
		for _, e := range m.GameArenas {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.TimeStamp != 0 {
		n += 1 + sovApi(uint64(m.TimeStamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteGameArenaReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameArena != nil {
		l = m.GameArena.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteGameArenaResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameArena) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.GroupId != 0 {
		n += 1 + sovApi(uint64(m.GroupId))
	}
	l = len(m.ArenaInfo)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ExtraData)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MatchId != 0 {
		n += 1 + sovApi(uint64(m.MatchId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadGameAvoidInjuryReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadGameAvoidInjuryResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProxyMap) > 0 {
		for k, v := range m.ProxyMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AvoidHurtMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovApi(uint64(m.GameId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if len(m.AvoidHurtMap) > 0 {
		for k, v := range m.AvoidHurtMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AvoidHurt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != 0 {
		n += 1 + sovApi(uint64(m.Left))
	}
	if m.Right != 0 {
		n += 1 + sovApi(uint64(m.Right))
	}
	if m.Extra != 0 {
		n += 1 + sovApi(uint64(m.Extra))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ZSetLoadRangeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetLoadRangeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetLoadRangeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZSetRangeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetRangeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetRangeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZSetLoadRangeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetLoadRangeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetLoadRangeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rank = append(m.Rank, &ZSetRangeData{})
			if err := m.Rank[len(m.Rank)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZSetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZSetGetScoreResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetGetScoreResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetGetScoreResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZSetUpdateScoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetUpdateScoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetUpdateScoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZSetGetRankResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetGetRankResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetGetRankResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZSetRefreshRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZSetRefreshRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZSetRefreshRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			m.Delta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delta |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HListLoadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HListLoadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HListLoadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HListLoadRangeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HListLoadRangeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HListLoadRangeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HListPopResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HListPopResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HListPopResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateKeyValuesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateKeyValuesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateKeyValuesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &KeyValue{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadValuesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadValuesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadValuesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadValuesResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadValuesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadValuesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &KeyValue{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetExpireReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetExpireReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetExpireReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadExpireReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadExpireReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadExpireReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadExpireResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadExpireResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadExpireResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrGameDataReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrGameDataReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrGameDataReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadGameDataReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadGameDataReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadGameDataReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadGameDataResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadGameDataResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadGameDataResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMembersResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMembersResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMembersResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRandomReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetRandomReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetRandomReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRandomResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetRandomResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetRandomResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetIsMemberResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetIsMemberResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetIsMemberResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMember = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &KeyValue{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetLoadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetLoadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetLoadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetLoadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetLoadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetLoadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &KeyValue{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetDelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetDelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetDelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetUpdateValuesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetUpdateValuesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetUpdateValuesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &KeyValue{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetLoadValuesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetLoadValuesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetLoadValuesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetLoadValuesResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetLoadValuesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetLoadValuesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &KeyValue{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetDelValuesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetDelValuesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetDelValuesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetDelHashReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetDelHashReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetDelHashReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetAddReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetAddReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetAddReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &KeyValue{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HSetIncrReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HSetIncrReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HSetIncrReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &KeyValue{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGameArenaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGameArenaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGameArenaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameArena", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameArena == nil {
				m.GameArena = &GameArena{}
			}
			if err := m.GameArena.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGameArenaResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGameArenaResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGameArenaResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameArenaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameArenaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameArenaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameArenaResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameArenaResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameArenaResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameArenas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameArenas = append(m.GameArenas, &GameArena{})
			if err := m.GameArenas[len(m.GameArenas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteGameArenaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteGameArenaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteGameArenaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameArena", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameArena == nil {
				m.GameArena = &GameArena{}
			}
			if err := m.GameArena.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteGameArenaResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteGameArenaResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteGameArenaResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameArena) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameArena: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameArena: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArenaInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchId", wireType)
			}
			m.MatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadGameAvoidInjuryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadGameAvoidInjuryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadGameAvoidInjuryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadGameAvoidInjuryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadGameAvoidInjuryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadGameAvoidInjuryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyMap == nil {
				m.ProxyMap = make(map[string]*AvoidHurtMap)
			}
			var mapkey string
			var mapvalue *AvoidHurtMap
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AvoidHurtMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProxyMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvoidHurtMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvoidHurtMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvoidHurtMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvoidHurtMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvoidHurtMap == nil {
				m.AvoidHurtMap = make(map[string]*AvoidHurt)
			}
			var mapkey string
			var mapvalue *AvoidHurt
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AvoidHurt{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AvoidHurtMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvoidHurt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvoidHurt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvoidHurt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			m.Left = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Left |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			m.Right = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Right |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			m.Extra = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Extra |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
